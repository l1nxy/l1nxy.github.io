[{"categories":["Tech"],"content":" 前言最近把系统换成了CachyOS，用上了ZFS，这个发行版做的一些Tricky还是可以的，例如一些fish的脚本，还有软件与DE的自定义项都比较简洁，比ArcoLinux强上不少。 我的情况是有两块NVMe的硬盘，一块是Windows系统，一块则是CachyOS。我的期望是用Linux Boot Manager去引导两个操作系统，比用Windows Boot Manager去引导Linux要好操作不少。 ","date":"2023-10-05","objectID":"/systemd-boot-windows/:0:0","series":null,"tags":["Linux","CachyOS","ArchLinux"],"title":"systemd-boot添加Windows引导项","uri":"/systemd-boot-windows/#前言"},{"categories":["Tech"],"content":" 确定fs alias看了一下systemd-boot的文档，需要先安装 edk2-shell 来给systemd-boot 加个EFI shell: sudo pacman -S edk2-shell \u0026\u0026 cp /usr/share/edk2-shell/x64/Shell.efi /boot/shellx64.efi 然后在boot的时候选择EFI Shell，在shell中，输入map命令，可以得到所有盘的fs alias, 这里我们需要得到是另一块盘的EFI分区。 可以用blkid可以看到所有盘or分区的PARTUUID，在EFI shell的map命令的输出结果中，可以对应上具体的fs alias是哪个盘。 ","date":"2023-10-05","objectID":"/systemd-boot-windows/:0:0","series":null,"tags":["Linux","CachyOS","ArchLinux"],"title":"systemd-boot添加Windows引导项","uri":"/systemd-boot-windows/#确定fs-alias"},{"categories":["Tech"],"content":" 加上Boot脚本确定了fs alias后就好办了，在/boot/下面新建一个windows.nsh，内容如下： HD0b:EFI\\Microsoft\\Boot\\Bootmgfw.efi 在这里，我的windows EFI分区的fs alias是HD0b。 然后在/boot/loader/entries/下面新建一个引导项windows.conf： title Windows efi /shellx64.efi options -nointerrupt -noconsolein -noconsoleout windows.nsh 最后检查一下windows.nsh是否在/boot/目录下面，用bootctl list 看一下boot项的输出，我的输出如下： type: Boot Loader Specification Type #1 (.conf) title: Windows id: windows.conf source: /boot//loader/entries/windows.conf efi: /boot//shellx64.efi options: -nointerrupt -noconsolein -noconsoleout windows.nsh type: Boot Loader Specification Type #1 (.conf) title: Linux Cachyos Lts Lto (default) (selected) id: linux-cachyos-lts-lto.conf source: /boot//loader/entries/linux-cachyos-lts-lto.conf linux: /boot//vmlinuz-linux-cachyos-lts-lto initrd: /boot//amd-ucode.img /boot//initramfs-linux-cachyos-lts-lto.img options: zfs=zpcachyos/ROOT/cos/root rw zswap.enabled=0 nowatchdog type: Boot Loader Specification Type #1 (.conf) title: Linux Cachyos Lts Lto (Fallback) id: linux-cachyos-lts-lto-fallback.conf source: /boot//loader/entries/linux-cachyos-lts-lto-fallback.conf linux: /boot//vmlinuz-linux-cachyos-lts-lto initrd: /boot//amd-ucode.img /boot//initramfs-linux-cachyos-lts-lto-fallback.img options: zfs=zpcachyos/ROOT/cos/root rw 可以确定的是，如果输出正确，那么就可以在引导的时候选择windows了。 PS，如果要改默认选择项，在/boot/loader/loader.conf 中可以改掉默认引导项，或者使用bootctl set-default 来指定。 ","date":"2023-10-05","objectID":"/systemd-boot-windows/:0:0","series":null,"tags":["Linux","CachyOS","ArchLinux"],"title":"systemd-boot添加Windows引导项","uri":"/systemd-boot-windows/#加上boot脚本"},{"categories":null,"content":" 暗香·旧时月色[宋]姜夔 旧时月色，算几番照我，梅边吹笛? 唤起玉人，不管清寒与攀摘。 何逊而今渐老，都忘却春风词笔。 但怪得竹外疏花，香冷入瑶席。 江国，正寂寂，叹寄与路遥，夜雪初积。。 翠尊易泣，红萼无言耿相忆。 长记曾携手处，千树压、西湖寒碧。又片片、吹尽也，几时见得? ","date":"2023-08-07","objectID":"/about/:0:0","series":null,"tags":null,"title":"About","uri":"/about/#"},{"categories":["Tech"],"content":" raft基础一个raft集群一般来说有5个服务器结点，能让系统承受其中任意两台的down掉。每个服务器一共有三个状态，leader,follower,candidate,follower被动的接受来自candidate与leader的消息并作出回应。leader handle了所有了所有的客户端的请求，如果follower接收到了请求，会重定向到leader那去。 raft把时间分成任意长的阶段，从选举开始，每个阶段都是一个连续增长的整数，至少有一个或者多个candidate会尝试成为leader。如果有一个candidate成为了leader，则接下来的term，它将是leader。在一些情况下，选举会出现，平分票数的情况，这种情况，term将会维持没有leader的状态到结束，到下一次的新的选举。 不同的服务器 可能感知不到不同的term之间的转换，或者根本不知道有选举这回事，在这其中，term充当了一个逻辑时钟的作用，能让服务器能检测过时的信息，比如落后的leader。每一个服务器有一个current term number，随着时间增长，当服务器之间通信时，current term 会被 交换，如果有一个服务器的term小于别的，就会更新自己的，如果一个canditate或者leader发现它自己的term过时了，就会马上转变成follower，如果服务器收到了一个过时的请求，则会直接拒绝这个请求。 raft的服务器之间用rpc请行通信，其中RequestVote用于canditate 来进行选举，AppendEntries 用于分发log与当心跳包（事实上是无论收到一个请求，都应该重置time out chekcer）。另外 还有一个转移快照的rpc。之后 再说。 ","date":"2020-08-30","objectID":"/raft-notes/:0:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#raft基础"},{"categories":["Tech"],"content":" 选举raft使用心跳机制来触发选举。当服务器启动的时候，它们都是follower，follower在收到来自leader或者 candidate合法的rpc请求之前，一直是follower，leader会周期性的发送心跳包来保持leader的权威性，心跳包是一个空的AppendEntries，不带有Log entries。当一个follower一个election timeout后没有收到心跳包，则认为leader没了，将开始一轮选举，选出一个新的leader。 为了开始一次选举，follower会给current term+1然后转变成candidate，然后投自己一票，然后同时发起RequestVote RPC给别的服务器。一个candidate会持续到以下三件情况出现，(a)它成了leader，(b)其它服务器成了leader(c)一段时间过去后，没有server成为leader。这将在之后讨论（应该是过一段时间重新发起） 一个candidate如果收到了整个集群中大多数的投票 (with same term)，就会成为leader。每一个服务器最多只能投出一票。这个大多数 的规则决定了，在一个term里，只能一个candidate成为leader。一旦candidate成为了leader，则会开始发送心跳包给其它所有的服务器，来保证自己的权威与阻止其它服务器发起选举。 在投票的过程中，可能 会收到来其它服务器发来的AppendEntries RPC来声称自己是leader，这种情况，看leader的term与自己的current term的大小，如果比自己大，那别人就是leader，自己将退回到follower的状态，如果比自己小，就是拒绝别人的RPC call，并继续进行选举。 一个选举如果选不出一个leader那就是分裂的选举，即没人得到大多数票，这种情况下，会等待超时直到下一次的选举，但是如果 没有做额外的操作，分裂的选举会不停的进行下去。 raft采用了随机的选举超时来保证split vote是很少见的并且能快速的被解决。即每一个服务器的election timeout不一样，在重新发起选举的之前会等待这个timeout，timeout少的会先发起选举。一般的timeout会选择一个区间比如150-300ms之间。这样会有一个服务器超时完成并在别的服务器节点超时完成前完成选举。 ","date":"2020-08-30","objectID":"/raft-notes/:0:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#选举"},{"categories":["Tech"],"content":" Log replication一旦一个leader被选举，那它就开始接受client的请求，每一个client的请求都包含一个命令，这个命令会被 replicated state machines执行，leader将会把这个command append到日志中去，作为一个新的entry，然后用AppendEntries 分发到其它的服务器。 leader会永远的尝试去写入follower log entry，直到所有的log entry都被 写入。 leader决定什么时候日志被 commit，当大多数的服务器都复制了一份entry后，就会提交，也会提前之前的entries，论文中设计了两个重要的属性 如果不同日志中的两个Entry有一样的index跟term，那他们存的一个东西 如果不同日志中的两个entry有一样的index跟term，那他们之前的所有entry是相同的。 属性1保证了，在给定的term与index中只会创建一个entry，属性2保证了一致性的简单性。 如果follower发现leader发过来的index跟term在自己的log里没有，那么会拒绝这个新的entry。（因为在消息中包含了这条新的之前的index跟term，所以可以检测之前的一致性，如果之前的都不一致就根本不会append这个新的） 在Raft中，处理leader与follower的不一致性是通过强制把leader的log记录复制给follower来完成的，这意味着follower的log的冲突部分，会被完全覆盖。 为了使follwer的log保持一致，leader必须找到leader与follwer最近的一个一样的entry，然后把这个之后的log都发给follower。 leader对于每一个follower都维护了一个index，这个index是leader将要发给follower的下一个index，当一个leader上台后， 会把这个next index初始化为自己log中的最后一个index，如果有follower的记录与leader不一致，那么在下一次Append Entries RPC的一致性检查中失败。当这个调用失败后，leader将决定下一个next index是多少，最终，next index会在重试中到达leader与follower一致的地方。当RPC调用成功之后，leader会把之后的记录全发给follower，这样就follower就完成了与leader的一致性同步。 leader永远不会改自己的log。这是强保证。 ","date":"2020-08-30","objectID":"/raft-notes/:0:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#log-replication"},{"categories":["Tech"],"content":" 强约束为了达成算法的强一致性，必须加上一些强约束。 ","date":"2020-08-30","objectID":"/raft-notes/:0:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#强约束"},{"categories":["Tech"],"content":" 选举RPC必须包含candidate的log，然后投票者看canditate的log是否比自己的旧，如果旧，则会拒绝投给它，这样会保证选举出来的leader跟大多数的投票者中的log是一致的。 ","date":"2020-08-30","objectID":"/raft-notes/:1:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#选举-1"},{"categories":["Tech"],"content":" 非提交的entryraft不会提交之前阶段的非提交的entry。对于raft来说，如果leader当前的entry提交了，其中的潜在的语义包含了之前的entry都是提交了的。 ","date":"2020-08-30","objectID":"/raft-notes/:2:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#非提交的entry"},{"categories":["Tech"],"content":" 安全性争论这部分主要是证明future term的log是 一定包含了之前term的提交的，因为如果没提交的话，会有两个矛盾，第一，它成为不了leader，第二，它的entry log一定比之前的要大。原文中用的反证法，说term U没有包含term T的 log。实际上，在投票的时候 它成为不了leader，另外一个就是假如它是leader，它的log也得包含之前的，不然提交不了到follower。 ","date":"2020-08-30","objectID":"/raft-notes/:3:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#安全性争论"},{"categories":["Tech"],"content":" 崩溃如果follower或者candidate崩溃了，leader会一直发请求，直到成功，如果follower在commit log之后但是没有回复，之后重启了，发现收到了同样index的entry写入请求，会忽视这个请求。 ","date":"2020-08-30","objectID":"/raft-notes/:4:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#崩溃"},{"categories":["Tech"],"content":" 时间与可用性raft的安全性不应该依赖时间：系统不应该因为一些事件发生的比预期的慢或者快就产生错误的结果。然而可用性却是不可避免的依赖时间。例如，因为如果回复慢了，follower就要变成candidate了。 其中leader election是raft中对时间最敏感的。raft将会选出一个稳定的leader，且这个系统满足这样的延迟要求：broadcastTime \u003c electionTimout \u003c MTBF。 广播时间应该要比选举超时少一个数量级，而选举时间应该要比恢复时间要少几个数量级。这样当leader崩溃的时候，也只有选举时间内不可用而已。 通常来说broadcasttim从0.5ms到20ms不等，而选举超时从10 ms 到500ms不等。而mtbf几个月。 ","date":"2020-08-30","objectID":"/raft-notes/:5:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#时间与可用性"},{"categories":["Tech"],"content":"这篇文章来自于Github的一篇关于Rust size的一些介绍，本文内容基本上是这文章的总结。可以话尽量看原文。 ","date":"2020-08-24","objectID":"/rust-sized-type/:0:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#"},{"categories":["Tech"],"content":" 介绍sideness在Rust中是一个比较底层的概念，但是又比较重要，而且与许多Rust特性有关系。通常我们能在编译器的错误信息中看到x doesn't have size known at compile time，那么到底什么是sized type；什么是unsized type以及什么是zero-sized type。他们应该怎么使用，和一些优缺点。 这有一张表是以一个总的视角来看Rust的type。 Phrase Shorthand for sizedness property of being sized or unsized sized type type with a known size at compile time 1) unsized type or 2) DST dynamically-sized type, i.e. size not known at compile time ?sized type type that may or may not be sized unsized coercion coercing a sized type into an unsized type ZST zero-sized type, i.e. instances of the type are 0 bytes in size width single unit of measurement of pointer width 1) thin pointer or 2) single-width pointer pointer that is 1 width 1) fat pointer or 2) double-width pointer pointer that is 2 widths 1) pointer or 2) reference some pointer of some width, width will be clarified by context slice double-width pointer to a dynamically sized view into some array ","date":"2020-08-24","objectID":"/rust-sized-type/:0:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#介绍"},{"categories":["Tech"],"content":" sizedness到底什么叫sizedness呢，在Rust中，如果一个类型的大小能在编译器能确定下来，那就是一个sized type。确定一个类型的大小是非常重要的，因为这关系到在stack上申请多大内存，一个确定大小的类型能够pass by value and ref。如果一个type是 unsized type or DST(dynamic Sized Type)那么它就不能在stack上申请内存，这两种情况的变量只能pass by ref。 use std::mem::size_of; fn main() { // primitives assert_eq!(4, size_of::\u003ci32\u003e()); assert_eq!(8, size_of::\u003cf64\u003e()); // tuples assert_eq!(8, size_of::\u003c(i32, i32)\u003e()); // arrays assert_eq!(0, size_of::\u003c[i32; 0]\u003e()); assert_eq!(12, size_of::\u003c[i32; 3]\u003e()); struct Point { x: i32, y: i32, } // structs assert_eq!(8, size_of::\u003cPoint\u003e()); // enums assert_eq!(8, size_of::\u003cOption\u003ci32\u003e\u003e()); // get pointer width, will be // 4 bytes wide on 32-bit targets or // 8 bytes wide on 64-bit targets const WIDTH: usize = size_of::\u003c\u0026()\u003e(); // pointers to sized types are 1 width assert_eq!(WIDTH, size_of::\u003c\u0026i32\u003e()); assert_eq!(WIDTH, size_of::\u003c\u0026mut i32\u003e()); assert_eq!(WIDTH, size_of::\u003cBox\u003ci32\u003e\u003e()); assert_eq!(WIDTH, size_of::\u003cfn(i32) -\u003e i32\u003e()); const DOUBLE_WIDTH: usize = 2 * WIDTH; // unsized struct struct Unsized { unsized_field: [i32], } // pointers to unsized types are 2 widths assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026str\u003e()); // slice assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026[i32]\u003e()); // slice assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026dyn ToString\u003e()); // trait object assert_eq!(DOUBLE_WIDTH, size_of::\u003cBox\u003cdyn ToString\u003e\u003e()); // trait object assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026Unsized\u003e()); // user-defined unsized type // unsized types size_of::\u003cstr\u003e(); // compile error size_of::\u003c[i32]\u003e(); // compile error size_of::\u003cdyn ToString\u003e(); // compile error size_of::\u003cUnsized\u003e(); // compile error } 从上面的代码可以看出来，Rust中的原生类型都有确定的大小，像struct,enum,array，以及由原生与类型与指针或者其它nested struct enum等组成的类型都能在编译期确定大小。而像slice是不能确定大小的，因为我们并不知道这个slice到底会多大，这些只有运行时才会知道。 一个指向动态大小视图的指针称为slice，比如\u0026str就是string slice slice两个width大小是因为存了一个指向数据的指针与元素的数量 trait两个width大小是因为存一个指向数据的指针与指向虚表的指针 unsized struct两个width大小是因为存了一个指针与这个struct 的大小 unsized struct只能一个unsized filed而且这个必须是struct中的最后一个字段 下面有些例子可以看slice跟array的区别： use std::mem::size_of; const WIDTH: usize = size_of::\u003c\u0026()\u003e(); const DOUBLE_WIDTH: usize = 2 * WIDTH; fn main() { // data length stored in type // an [i32; 3] is an array of three i32s let nums: \u0026[i32; 3] = \u0026[1, 2, 3]; // single-width pointer assert_eq!(WIDTH, size_of::\u003c\u0026[i32; 3]\u003e()); let mut sum = 0; // can iterate over nums safely // Rust knows it's exactly 3 elements for num in nums { sum += num; } assert_eq!(6, sum); // unsized coercion from [i32; 3] to [i32] // data length now stored in pointer let nums: \u0026[i32] = \u0026[1, 2, 3]; // double-width pointer required to also store data length assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026[i32]\u003e()); let mut sum = 0; // can iterate over nums safely // Rust knows it's exactly 3 elements for num in nums { sum += num; } assert_eq!(6, sum); } 下面有些例子可以看struct 与 trait的区别： use std::mem::size_of; const WIDTH: usize = size_of::\u003c\u0026()\u003e(); const DOUBLE_WIDTH: usize = 2 * WIDTH; trait Trait { fn print(\u0026self); } struct Struct; struct Struct2; impl Trait for Struct { fn print(\u0026self) { println!(\"struct\"); } } impl Trait for Struct2 { fn print(\u0026self) { println!(\"struct2\"); } } fn print_struct(s: \u0026Struct) { // always prints \"struct\" // this is known at compile-time s.print(); // single-width pointer assert_eq!(WIDTH, size_of::\u003c\u0026Struct\u003e()); } fn print_struct2(s2: \u0026Struct2) { // always prints \"struct2\" // this is known at compile-time s2.print(); // single-width pointer assert_eq!(WIDTH, size_of::\u003c\u0026Struct2\u003e()); } fn print_trait(t: \u0026dyn Trait) { // print \"struct\" or \"struct2\" ? // this is unknown at compile-time t.print(); // Rust has to check the pointer at run-time // to figure out whether to use Struct's // or Struct2's implementation of \"print\" // so the pointer has to be double-width assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026dyn Trait\u003e()); } fn main() { // single-width pointer to data let s = \u0026Struct; print_struct(s); // prints \"struct\" // single-width pointer to data let s2 = \u0026Struct2; print_struct2(s2); // prints \"struct2\" // unsized coercion from Struct to dyn Tr","date":"2020-08-24","objectID":"/rust-sized-type/:1:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#sizedness"},{"categories":["Tech"],"content":" Sized TraitSized trait是Rust一个marker trait和auto trait。auto trait是说如果一个类型满足了条件则会被自动实现。而markter trait说用来标记一个类型是某个特定的属性的。marker trait没有任何的trait item，比如函数，变量等。所有的auto trait都是marker trait，但是不是所有的marker trait都是auto trait。auto trait必须得是marker trait，这样编译器才能提供一个默认的实现 。 一个类型如果它的所有的成员都是sized的，那么它就是Sized。同样的trait还有Send与Sync。如果一个类型能安全地在线程间传递，那么它就是Send的，如果一个类型能在线程间安全的shared ref，那就是Sync的。但是Sized有点不同的是，不能对一个类型把它去掉： #![feature(negative_impls)] // this type is Sized, Send, and Sync struct Struct; // opt-out of Send trait impl !Send for Struct {} // opt-out of Sync trait impl !Sync for Struct {} impl !Sized for Struct {} // compile error ","date":"2020-08-24","objectID":"/rust-sized-type/:2:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#sized-trait"},{"categories":["Tech"],"content":" 泛型参数中的Sized// this generic function... fn func\u003cT\u003e(t: T) {} // ...desugars to... fn func\u003cT: Sized\u003e(t: T) {} // ...which we can opt-out of by explicitly setting ?Sized... fn func\u003cT: ?Sized\u003e(t: T) {} // compile error // ...which doesn't compile since t doesn't have // a known size so we must put it behind a pointer... fn func\u003cT: ?Sized\u003e(t: \u0026T) {} // compiles fn func\u003cT: ?Sized\u003e(t: Box\u003cT\u003e) {} // compiles 当我们写下一个泛型函数时，T就得到了Sized的trait。 ?Sized意思是这个类型可能是Sized或者是也许Sized的。这能让类型可以是Sized也可以的Unsized。 ?Sized一般用来减少参数的约束，且是Rust中唯一能减少约束的措施。 一般来说，我们还是需要放松对泛型参数的约束，因为实例化的时候， 实际类型可能是Sized也有可能是Unsized。 有如下代码： use std::fmt::Debug; fn debug\u003cT: Debug\u003e(t: T) { // T: Debug + Sized println!(\"{:?}\", t); } fn main() { debug(\"my str\"); // T = \u0026str, \u0026str: Debug + Sized ✔️ 虽然这样可行，但是如果参数是个ref呢？ use std::fmt::Debug; fn dbg\u003cT: Debug\u003e(t: \u0026T) { // T: Debug + Sized println!(\"{:?}\", t); } fn main() { dbg(\"my str\"); // \u0026T = \u0026str, T = str, str: Debug + !Sized ❌ } 错误如下： error[E0277]: the size for values of type `str` cannot be known at compilation time --\u003e src/main.rs:8:9 | 3 | fn dbg\u003cT: Debug\u003e(t: \u0026T) { | - required by this bound in `dbg` ... 8 | dbg(\"my str\"); | ^^^^^^^^ doesn't have a size known at compile-time | = help: the trait `std::marker::Sized` is not implemented for `str` = note: to learn more, visit \u003chttps://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\u003e help: consider relaxing the implicit `Sized` restriction | 3 | fn dbg\u003cT: Debug + ?Sized\u003e(t: \u0026T) { | 这其中的类型也许有点怪，但是看表就很好理解了： Type T \u0026T \u0026str T = \u0026str T = str Type Sized str ❌ \u0026str ✔️ \u0026\u0026str ✔️ 所以最好对泛型参数加上一个?Sized的标记来放松对类型的约束。 ","date":"2020-08-24","objectID":"/rust-sized-type/:3:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#泛型参数中的sized"},{"categories":["Tech"],"content":" Unsized type","date":"2020-08-24","objectID":"/rust-sized-type/:4:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#unsized-type"},{"categories":["Tech"],"content":" slices最常见的切片是str与数组的切片\u0026[T]。切片的一个优点是许多的类型都能转换成它们。强制类型转换在Rust中很常见，特别是在函数参数中。一种类型转换是deref和unsized。一个deref转换是当T通过一个deref操作转换成U，比如T:Deref\u003cTarget=U\u003e比如STring.deref() -\u003e str。一个unsized转换是把T转换成U，其中T是sized type 而U是unsized type。比如T:Unsized\u003cU\u003e，[i32;3] -\u003e[i32]。 trait Trait { fn method(\u0026self) {} } impl Trait for str { // can now call \"method\" on // 1) str or // 2) String since String: Deref\u003cTarget = str\u003e } impl\u003cT\u003e Trait for [T] { // can now call \"method\" on // 1) any \u0026[T] // 2) any U where U: Deref\u003cTarget = [T]\u003e, e.g. Vec\u003cT\u003e // 3) [T; N] for any N, since [T; N]: Unsize\u003c[T]\u003e } fn str_fun(s: \u0026str) {} fn slice_fun\u003cT\u003e(s: \u0026[T]) {} fn main() { let str_slice: \u0026str = \"str slice\"; let string: String = \"string\".to_owned(); // function args str_fun(str_slice); str_fun(\u0026string); // deref coercion // method calls str_slice.method(); string.method(); // deref coercion let slice: \u0026[i32] = \u0026[1]; let three_array: [i32; 3] = [1, 2, 3]; let five_array: [i32; 5] = [1, 2, 3, 4, 5]; let vec: Vec\u003ci32\u003e = vec![1]; // function args slice_fun(slice); slice_fun(\u0026vec); // deref coercion slice_fun(\u0026three_array); // unsized coercion slice_fun(\u0026five_array); // unsized coercion // method calls slice.method(); vec.method(); // deref coercion three_array.method(); // unsized coercion five_array.method(); // unsized coercion } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:1","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#slices"},{"categories":["Tech"],"content":" Trait Object对于一个Trait来说，是?Sized的。因为不知道是Sized type 还是unsized type会去实现它。 Trait : ?Sized对于impl Trait for dyn Trait是必要的。 我们能对每一个方法加个Self:Sized的约束，但是不能给Trait加个Sized约束。 Trait Object 的局限性 不能把一个Unsized的类型转换成Trait Object fn generic\u003cT: ToString\u003e(t: T) {} fn trait_object(t: \u0026dyn ToString) {} fn main() { generic(String::from(\"String\")); // compiles generic(\"str\"); // compiles trait_object(\u0026String::from(\"String\")); // compiles, unsized coercion trait_object(\"str\"); // compile error, unsized coercion impossible } 不能创造出多Trait的object的动态分发：因为要存两个trait的vtable要更多的内存，而正确的组合方式如下： trait Trait { fn method(\u0026self) {} } trait Trait2 { fn method2(\u0026self) {} } trait Trait3: Trait + Trait2 {} // auto blanket impl Trait3 for any type that also impls Trait \u0026 Trait2 impl\u003cT: Trait + Trait2\u003e Trait3 for T {} // from `dyn Trait + Trait2` to `dyn Trait3` fn function(t: \u0026dyn Trait3) { t.method(); // compiles t.method2(); // compiles } Rust的trait不支持向上转换： trait Trait { fn method(\u0026self) {} } trait Trait2 { fn method2(\u0026self) {} } trait Trait3: Trait + Trait2 {} impl\u003cT: Trait + Trait2\u003e Trait3 for T {} struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026dyn Trait) {} fn takes_trait2(t: \u0026dyn Trait2) {} fn main() { let t: \u0026dyn Trait3 = \u0026Struct; takes_trait(t); // compile error takes_trait2(t); // compile error } 一个正确的做法的是去写显式的转换函数： trait Trait {} trait Trait2 {} trait Trait3: Trait + Trait2 { fn as_trait(\u0026self) -\u003e \u0026dyn Trait; fn as_trait2(\u0026self) -\u003e \u0026dyn Trait2; } impl\u003cT: Trait + Trait2\u003e Trait3 for T { fn as_trait(\u0026self) -\u003e \u0026dyn Trait { self } fn as_trait2(\u0026self) -\u003e \u0026dyn Trait2 { self } } struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026dyn Trait) {} fn takes_trait2(t: \u0026dyn Trait2) {} fn main() { let t: \u0026dyn Trait3 = \u0026Struct; takes_trait(t.as_trait()); // compiles takes_trait2(t.as_trait2()); // compiles } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:2","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#trait-object"},{"categories":["Tech"],"content":" Trait Object对于一个Trait来说，是?Sized的。因为不知道是Sized type 还是unsized type会去实现它。 Trait : ?Sized对于impl Trait for dyn Trait是必要的。 我们能对每一个方法加个Self:Sized的约束，但是不能给Trait加个Sized约束。 Trait Object 的局限性 不能把一个Unsized的类型转换成Trait Object fn generic(t: T) {} fn trait_object(t: \u0026dyn ToString) {} fn main() { generic(String::from(\"String\")); // compiles generic(\"str\"); // compiles trait_object(\u0026String::from(\"String\")); // compiles, unsized coercion trait_object(\"str\"); // compile error, unsized coercion impossible } 不能创造出多Trait的object的动态分发：因为要存两个trait的vtable要更多的内存，而正确的组合方式如下： trait Trait { fn method(\u0026self) {} } trait Trait2 { fn method2(\u0026self) {} } trait Trait3: Trait + Trait2 {} // auto blanket impl Trait3 for any type that also impls Trait \u0026 Trait2 impl Trait3 for T {} // from `dyn Trait + Trait2` to `dyn Trait3` fn function(t: \u0026dyn Trait3) { t.method(); // compiles t.method2(); // compiles } Rust的trait不支持向上转换： trait Trait { fn method(\u0026self) {} } trait Trait2 { fn method2(\u0026self) {} } trait Trait3: Trait + Trait2 {} impl Trait3 for T {} struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026dyn Trait) {} fn takes_trait2(t: \u0026dyn Trait2) {} fn main() { let t: \u0026dyn Trait3 = \u0026Struct; takes_trait(t); // compile error takes_trait2(t); // compile error } 一个正确的做法的是去写显式的转换函数： trait Trait {} trait Trait2 {} trait Trait3: Trait + Trait2 { fn as_trait(\u0026self) -\u003e \u0026dyn Trait; fn as_trait2(\u0026self) -\u003e \u0026dyn Trait2; } impl Trait3 for T { fn as_trait(\u0026self) -\u003e \u0026dyn Trait { self } fn as_trait2(\u0026self) -\u003e \u0026dyn Trait2 { self } } struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026dyn Trait) {} fn takes_trait2(t: \u0026dyn Trait2) {} fn main() { let t: \u0026dyn Trait3 = \u0026Struct; takes_trait(t.as_trait()); // compiles takes_trait2(t.as_trait2()); // compiles } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:2","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#trait-object-的局限性"},{"categories":["Tech"],"content":" User-Defined Unsized Typestruct Unsized { unsized_field: [i32], } 定义一个unsized type的方法是，给struct一个unsize filed。这个unsized filed只能一个，且是最后一个。 如果要定义一个不知道是不是Unsized type的struct，最好是用泛型去定义这个struct。 我们常用的std::ffi:OsStr与std::path::Path就是标准库中的unsized struct。 ","date":"2020-08-24","objectID":"/rust-sized-type/:4:3","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#user-defined-unsized-type"},{"categories":["Tech"],"content":" Zero-Sized TypesUnit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。 尽管()是0大小类型，但是还是能给它实现一些trait： use std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026self, _other: \u0026()) -\u003e bool { true } fn ne(\u0026self, _other: \u0026()) -\u003e bool { false } } impl Ord for () { fn cmp(\u0026self, _other: \u0026()) -\u003e Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如： fn main() { // zero capacity is all the capacity we need to \"store\" infinitely many () let mut vec: Vec\u003c()\u003e = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。 User-Defined Unit Structs用户定义的Unit Struct: struct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。 Never typeNever type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是： !能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型 而第二点可以实现出一定会成功的函数: fn function() -\u003e Result\u003cSuccess, !\u003e; 而fn function() -\u003e Result\u003c!, Error\u003e;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。 User-Defined Pseudo Never Type我们可以用用户自定义的never type来实现永远不会失败的函数： enum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026str) -\u003e Result\u003cString, Self::Err\u003e { Ok(String::from(s)) } } // example 2 fn run_server() -\u003e Result\u003cVoid, ConnectionError\u003e { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:4","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#zero-sized-types"},{"categories":["Tech"],"content":" Zero-Sized TypesUnit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。 尽管()是0大小类型，但是还是能给它实现一些trait： use std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026self, _other: \u0026()) -\u003e bool { true } fn ne(\u0026self, _other: \u0026()) -\u003e bool { false } } impl Ord for () { fn cmp(\u0026self, _other: \u0026()) -\u003e Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如： fn main() { // zero capacity is all the capacity we need to \"store\" infinitely many () let mut vec: Vec\u003c()\u003e = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。 User-Defined Unit Structs用户定义的Unit Struct: struct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。 Never typeNever type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是： !能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型 而第二点可以实现出一定会成功的函数: fn function() -\u003e Result; 而fn function() -\u003e Result\u003c!, Error\u003e;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。 User-Defined Pseudo Never Type我们可以用用户自定义的never type来实现永远不会失败的函数： enum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026str) -\u003e Result { Ok(String::from(s)) } } // example 2 fn run_server() -\u003e Result { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:4","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#user-defined-unit-structs"},{"categories":["Tech"],"content":" Zero-Sized TypesUnit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。 尽管()是0大小类型，但是还是能给它实现一些trait： use std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026self, _other: \u0026()) -\u003e bool { true } fn ne(\u0026self, _other: \u0026()) -\u003e bool { false } } impl Ord for () { fn cmp(\u0026self, _other: \u0026()) -\u003e Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如： fn main() { // zero capacity is all the capacity we need to \"store\" infinitely many () let mut vec: Vec\u003c()\u003e = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。 User-Defined Unit Structs用户定义的Unit Struct: struct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。 Never typeNever type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是： !能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型 而第二点可以实现出一定会成功的函数: fn function() -\u003e Result; 而fn function() -\u003e Result\u003c!, Error\u003e;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。 User-Defined Pseudo Never Type我们可以用用户自定义的never type来实现永远不会失败的函数： enum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026str) -\u003e Result { Ok(String::from(s)) } } // example 2 fn run_server() -\u003e Result { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:4","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#never-type"},{"categories":["Tech"],"content":" Zero-Sized TypesUnit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。 尽管()是0大小类型，但是还是能给它实现一些trait： use std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026self, _other: \u0026()) -\u003e bool { true } fn ne(\u0026self, _other: \u0026()) -\u003e bool { false } } impl Ord for () { fn cmp(\u0026self, _other: \u0026()) -\u003e Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如： fn main() { // zero capacity is all the capacity we need to \"store\" infinitely many () let mut vec: Vec\u003c()\u003e = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。 User-Defined Unit Structs用户定义的Unit Struct: struct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。 Never typeNever type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是： !能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型 而第二点可以实现出一定会成功的函数: fn function() -\u003e Result; 而fn function() -\u003e Result\u003c!, Error\u003e;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。 User-Defined Pseudo Never Type我们可以用用户自定义的never type来实现永远不会失败的函数： enum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026str) -\u003e Result { Ok(String::from(s)) } } // example 2 fn run_server() -\u003e Result { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:4","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#user-defined-pseudo-never-type"},{"categories":["Tech"],"content":" 前言MIT 6.824是著名的分布式课程，课程包含了视频，讲义，与作业。而本篇博文将阐述6.824课程的第一个作业的一些思考与解法，记录一些关于Map Reduce系统的思考。 ","date":"2020-07-02","objectID":"/map-reduce/:0:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#前言"},{"categories":["Tech"],"content":" Map ReduceMap Reduce作为“谷三篇”的第一篇，出名不是没有原因的，jeff dean的超前思想构建了谷歌搜索的基石，使得谷歌在超大应用系统的构建上得心应手。而Map Reduce则是一个基石中的基石。 Map Reduce的思想就是分布式的，系统中包含一个Master和许多个Worker，Master负责调度Worker与任务分发，容灾等等，Worker则与Master通信，请求任务。 而Map Reduce则把一个任务拆分成Map与Reduce部分，简单来说，Map部分是把输入通过用户定义的Map Function输出成中间文件，再把中间文件作为输入给Reduce，Reduce把中间文件调用Reduce Function，然后合并并输出。 整个系统如图所示。如论文所说，这些文件可以是在本地机器上，也可以在分布式文件系统中，这并不影响整个系统框架。 具体Map Reduce的思想可以读一下Google的论文。 ","date":"2020-07-02","objectID":"/map-reduce/:0:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#map-reduce"},{"categories":["Tech"],"content":" MIT 6.824 Lab1现代的6.824比以前的要难许多，我做过之前的lab1，当时就把Map Reduce的框架都搭好了，只要写两个函数就算通过了。而这个2020的6.824要求对Go熟悉且要把MapReduce整个实现一个大概出来，前后花了不少时间去思考要怎么来做这个实验。 ","date":"2020-07-02","objectID":"/map-reduce/:0:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#mit-6824-lab1"},{"categories":["Tech"],"content":" 思考当我们拿到Lab的时候需要做什么？需要思考我们要实现哪些东西。MIT的代码里只给了几个RPC的函数，然后在这个基础去实现Map Reduce。 而我们要做的有： 实现Master管理，这其中需要管理任务的状态，Worker请求任务的处理，Worker任务完成报告的处理，Worker失败超时的处理。 实现Worker请求任务，对Map部分任务的处理，对Reduce部分任务的处理，还有任务完成的上报。 还要实现一个文件锁，不能让Goroutine之间产生Race。 ","date":"2020-07-02","objectID":"/map-reduce/:1:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#思考"},{"categories":["Tech"],"content":" 实现我的一些方案是在Master的结构体里管理两个Channel，当Master启动之后，把任务发给MapChannel，然后在另一个Goroutine里面对这个MapChannel进行读取，Channel如果不设置的话，一方没有读，写方会阻塞住，所以只有Worker进行请求任务之后才会继续生产任务。当Map部分完成后，再启动Reduce部分，生产Reduce任务到ReduceChannel。 我们在每个请求任务的RPC返回之前再开启一个Goroutine来等待Worker的任务完成报告，这里我们用到了Go的select语法，并使用一个timer，如果超时就把这个任务再次Push进TaskChannel，即使任务失败了，也能再次把任务分发下去。 对于Worker部分的代码来说，完全就是苦力活，可以看看官方代码里那个非分布式的Worker里代码，可以直接复制过来。Worker如果联系不上Master了，马上退出进程，这样就不用实现一个退出语义了。（其实是我不知道怎么让Master去通知Worker退出） ","date":"2020-07-02","objectID":"/map-reduce/:2:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#实现"},{"categories":["Tech"],"content":" 代码这里只给出一些结构体的定义： Master: type Master struct { MapTaskList []*MapTask ReduceTaskList []*ReduceTask MapTaskChan chan *MapTask ReduceTaskChan chan *ReduceTask CompleteMapTaskNum int CompleteReduceTaskNum int mu sync.Mutex files []string nReduce int } Task Def type MapTask struct { TaskNum int TaskStatus TASK_STATUS FileName string NReduce int } type ReduceTask struct { TaskNum int TaskStatus TASK_STATUS FileName []string NReduce int } ","date":"2020-07-02","objectID":"/map-reduce/:3:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#代码"},{"categories":["Tech"],"content":" 一些吐槽这次写了蛮久了，因为不是很熟悉Go，学了一会才知道有select这种语法，然后官方的hint里让人把中间文件命名为mr-x-y.txt，这样其实挺坑的，因为testmr.sh里面没有把这个中间文件删除掉，而在文件读写的时候因为hash的缘故，不会把所有的文件清空，这样导致前一个test的中间文件会影响到后一个test。所以我加一个函数，把所有的中间文件清空的，这样也算是TDD吧。 接下来就是要做Lab2了，完成一个Raft。 ","date":"2020-07-02","objectID":"/map-reduce/:4:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#一些吐槽"}]