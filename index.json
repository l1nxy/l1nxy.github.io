[{"content":"basic of rust concurrency 内部可变性是指可以通一个不可变引用来实现对内部数据的修改。标准库中有Cell\u0026lt;T\u0026gt;，Cell相当于持有这个Obj，要做修改只能先把T move出来再把T塞回去。RefCell\u0026lt;T\u0026gt;不但持有这个obj，还会维护一个引用计数，如果在运行时有多个Mut借用时，会panic。\nRwLock是多线程版本的RefCell，但是多个可变借用时，或者说多个写时，会block住试图拿这个可变借用的线程，让它进入sleep。而Mutex不像Rwlock可以实现多个可读借用，mutex是彻底的独占的，其它线程都必须等待锁的释放。\nUnSafeCell是实现内部可变性的关键类型，它只有get函数可以得到一个底层类型的raw pointer,UnsafeCell没有任何保证安全性的限制，需要用户自己来进行安全性的保证。一般不会直接用unsafe cell，都是包装成另一个类型来限制使用，比如实现成cell或者mutex。\nSendtrait意味着这个类型的所有权可以在线程之间转移，Synctrait意味着这个类型可以在线程之间共享。\n一个struct如果所有的类型都是send和sync，那它本身也是send和sync的，如果要实现非send和sync的话，可以用phontomdata 标记类型。PhantomData用于标记Struct非sync，毕竟这是个zero sized type。\n给一些非auto trait实现send和sync是unsafe的，因为取决于其中类型的具体实现，所以安全性需要自己来保证。\nrust的mutex，实现了一个其它线程如果持有了mutex，但是panic了，这个mutex就是poison的机制：rust mutex doc。 mutex一些值得注意的点:\nif let的scope。\nif let Some(item) = list.lock().unwrap().pop() {//会lock到这个if结束 process_item(item); } if list.lock().unwrap().pop() == Some(1) {//在进入body前，MutxGuard就已经drop掉了。 do_something(); } rust 2024做出的一个if let的小修改，即if let的表达式生命周期不会延长到else body中去：rust 2024 doc\n大多数的读写锁的实现都会block新的读者出现，当写者等待时，因为可能会多个读者共享导致写者一直要等待，这是读写锁中一个经典的饥饿问题。 ## parking and condition variables 当一个线程在等待别的线程的通知的时候，这种叫thread parking，parking的时候，线程会进入睡眠，唤醒可以用unpark。 在实现上，unpark有一个很重要的特性是，有一个信号保留机制，即unpark在park之前执行了，这个park也不会让线程进入睡眠，因为消费者需要对生产者的每一个unpark都有响应，否则会有丢数据的风险。 但是unpark并不能叠加，所以unpark两次后，再Park两次还是会线程进入睡眠。\n条件变量一般是与mutex结合使用，传入同一个mutex，一个线程wait，一个线程notify。如果两个线程在操作同一个条件变量但是不同的mutex，会引起panic.\nAtomic and Memory order 原子类型可以在多线程间安全的访问和修改，但是依赖于Memory Ordering。比如最简单的order,Ralex,Relax只能保证单个变量的一致性，而多个变量间顺序无法保证。 atomic i32的溢出是回环的，不像普通的i32，溢出是会panic的。 为什么需要memory order?CPU会为了优化而把程序中的指令进行重排，写的是什么顺序，执行起来可能是别的顺序。 Happens before即保证A发生在B之前，但是在多线程中却是不一定的，使用锁可以保证，或者更严格的memory ordering。\nRelax Relaxed Ordering保证了单个atomic变量的总修改顺序.\nRelaase and Acquire Release与Acquire是成对使用，release给store，acquire给load。acquire-load可以观测到所有的release-store的操作，可以保证所有的store都会发生在load之前。同时，还有一个两者的结合体，即AcqRel。\nconsume 只能说，load发生的时候，取决于这个值的读取操作，只能说store肯定发生于相关表达式求值这前，而非相关的肯定不会。但是实际上所有的CPU都是实现为relax，而编译器根本不支持这个操作。不会保证全局顺序的一致性。\nSeqCst SeqCst保证了所有的acquire ordering与release ordering，也保证了全局操作顺序的一致性。如果在乎性能可以使用 seqcst fence与relaxed ordering来代替。\n实际上release store可以分解成fence与relaxed ordering,因为fence会导致同步： 所有的store在release fence后面 会被acquire fence之前被观测到，即同步\nUnderstanding the processor 在x86和arm下，最低要求的Relaxed的load和store，与普通变量的读取与写入是一样的。（我觉得主要原因是x86是TSO，远大于Relaxed的同步要求，而arm这是默认最低水平的同步要求。） 但是如果是Read-Modify-Write这样的顺序的话，比如*x+=1，这样的语句，对于x86来说，只有一条mov，这样是原子的，但是对于arm来说，这是三条指令，这意味着它并不是原子的了。 普通的add并不是原子的，因为在cpu看到会拆成好多条微指令，所以并不是原子的，如果要实现原子性的add或者其它操作，需要用到x86下的lock 前缀。 在x86下，add,sub,and not or xor都支持lock前缀，当它们加上了lock前缀之后，会block住其它核心 ，之后会将结果同步给其它核心，以完成同步。 只有add有xadd指针，x意味首exchange；对于bit，可以用bts，btr，btc指令来实现，这些指令也可以加lock。 而compare and exchange有cmpxchg 指令，可以实现比较然后交换。\nload-linked and store-conditinal instructions 对于RISC架构来说，LL/SC loop是最接近cmp and exchange语义的。其中包含了两个基本指令，一个load，一个store-conditional。与普通的load store不一样的是，如果在store的时候，有其它线程在load-link指令后写入内存，store会拒绝写入。 用这两个指令，可以实现读取，修改，写入，如果中间因为别的线程有修改写入失败了，则重试即可。 在x86用fetch等指令，可以生成与compare and exchange相同的指令，但是在arm上并不一定，这种优化实际上很难做，因为ll store中间能插的指令过少\ncache MESI的四个状态，modified：包含了本cach line修改了但是没有写回主存的数据，exclusive：只有本cache line有的数据，Shared：包含与别的cache 一样的数据，没有修改的数据，invalid:指cache line空的，或者dropped，意味着它没有任何有效数据。 对于多核CPU来着，cache 的状态变化会在这四个状态间切换，比如一个核心独占的cache，如果别的核心也需要的话，状态就会变成共享的。 另外也有一些变种的协议，加上一些别的状态，比如修改过的cache并不马上写回到下一个level中，而是同样可以共享。\n对性能的影响 use std::{hint::black_box, sync::atomic::AtomicU32, sync::atomic::Ordering::*, time::Instant}; static A: AtomicU32 = AtomicU32::new(0); fn main() { black_box(\u0026amp;A); std::thread::spawn(|| loop { black_box(A.store(1, Relaxed)); }); let start = Instant::now(); for _ in 0..1_000_000_000 { black_box(A.load(Relaxed)); } println!(\u0026#34;time is:{:?}\u0026#34;, start.elapsed()); } 这段代码，如果store改成load，那么cache line的同步的开销几乎可以不计，对多线程的load没有什么影响，但是如果是store，会有很大同步的开销的，在我的老笔记本上，这个执行时间从11秒变到了40秒（不是，我的笔记本也太差了，书中写的是现在的新x86CPU从200ms变成600ms）。\n原因是store的话，需要独占整个cache line，并且要写回到下一层，再被其它线程去load。如果把指令改成cmp \u0026amp; echg，也是一样的，因为无论cmp失败与否，它都需要独占cache line。\n如果是多个变量在同一条cache line上，对于这些变量的操作也会受到cache一致性的影响，性能会有所下降，最好是把不同的变量分到不同的cache line上。\nstatic A: [AtomicU32;3] = [AtomicU32::new(0),AtomicU32::new(0),AtomicU32::new(0)]; fn main() { black_box(\u0026amp;A); std::thread::spawn(|| loop { black_box(A[0].store(1, Relaxed)); black_box(A[2].store(1, Relaxed)); }); let start = Instant::now(); for _ in 0..1_000_000_000 { black_box(A[1].load(Relaxed)); } println!(\u0026#34;time is:{:?}\u0026#34;, start.elapsed()); } 输出结果\ntime is: 38.1021 而改进方法是，对变量填充padding，让它占满整个cache line，这样就会互不影响了。\n#[repr(align(64))] struct Aligned(AtomicU32); static A: [Aligned;3] = [Aligned(AtomicU32::new(0)),Aligned(AtomicU32::new(0)),Aligned(AtomicU32::new(0))]; fn main() { black_box(\u0026amp;A); std::thread::spawn(|| loop { black_box(A[0].0.store(1, Relaxed)); black_box(A[2].0.store(1, Relaxed)); }); let start = Instant::now(); for _ in 0..1_000_000_000 { black_box(A[1].0.load(Relaxed)); } println!(\u0026#34;time is:{:?}\u0026#34;, start.elapsed()); } 输出为time is 11.12121，可见影响是非常大的。\nReordering 指令重排不仅会发生在编译器生成的时候，而且也会发生指令乱序执行的情况。在现代CPU中，存在一些优化性能的机制，会导致指令的乱序执行。\nstore buffer CPU对cache的操作可能先存入store buffer中，然后先去执行别的指令，对于别的线程来说，可能要等store buffer写入了cache后，再通过MESI同步过去。\ninvaliation queue 同样对于缓存的失效也并不是马上落到cache中，而是先放入一个invaliation queue中，之后再进行失效操作，如果别的核心需要等待这个操作才能执行，那么会在queue写入到cache后才会执行。\npipeline 现代CPU的流水线是高度并行执行指令的，在CPU中会分析指令间的依赖关系，然后同时发射，但是对于编译生成的指令来着，却是乱序的。\n对于store buffer导致的指令重排，可以使用内存屏障来保证写操作一定在读操作之前。\nMemory ordering 在现代语言中，如果指定了内存模型的话，那么编译器会生成正确的指令，不会生成打破内存模型的重排指令。但是比如non-atomic操作与relaxed模型，重排是可以接收的，换句话说，重排与否与操作和内存模型有关系。 对于内存屏障来说，所有的acquire之后的操作都不能重排在acquire之前，而release之后的操作都不能重排到release之前。 对于GPU来说，复杂的缓存设计与内存设计可能会导致core1的操作与core2的操作在core3看来并不是按core1 core2约定的顺序执行的。而x86与arm，一个核心的操作对于其它核心是可见的，即保证了在其它核心看来也是同一样的顺序，这样数据不同步的问题在这两个架构来看，是能退化成指令重排的问题。arm用的是weakly ordering，可以允许可能的重排，而x86是strong ordering，对于指令重排有严格的限制。\n在x86上，保证了store-store的连续性，即store a与store一定是按写下的顺序写下的，同理load a与load b也是一样。唯一允许的重排是store after load，这指的是core1有load a 后面跟了一个store b操作，而core2可以通过store buffer forwarding等优化技术来先load b，这样观察顺序看来就是core1: load a-\u0026gt;store b-\u0026gt;load b-\u0026gt;store-a,core2: load-a load-b store a store b，这样的顺序，而实际执行顺序是没有变的。\n在x86上，可以说得到了免费的acquire-release语义的保障，可以说与relaxed模型一样的开销，因为non-atomic操作与atomic操作生成的汇编是一样的，除了SeqCst，要保证全局一致性需要把store改成xexchg，因为普通的store会可能重排。 可以说，在性能上只有store在不同内存序下有性能差异，而其它的load等操作在seqcst和relaxed操作下是没有差异的。\n在arm上，因为弱内存序，所有的指令都有可能发生重排。所以加上强内存序后，会生成强内存序的指令，可以保证一致性。而且acq-rel与seq-cst生成的代码是一样的。\n对于fence来说，在x86上，只有SeqCst下，才会生成mfence的指令，而在arm上都会生成dms的指令用于等待load store完成，并且防止指令重排。\nOperating system interface 在不同系统上，Rust基本上都通过libc去做syscall来完成与系统内核的交互： * linux上，syscall abi是稳定的，也可以通过汇编下的syscall来实现syscall，虽然这样更快，但是丧失了一些方便性。 * macos上，syscall abi不是稳定的，所以一般都是使用libc提供的posix接口来实现syscall。 * 在windows上也有kernel32.dll来提供syscall。\nposix posix标准下，有pthread作为线程库与同步原语: * pthread_mutex_t: 创建mutex为pthread_mutex_init,退出pthread_mutex_destroy，可以在init在时候传入attr参数来指定一些属性，一个比较重要的属性是重入性，默认情况下PTHREAD_MUTEX_DEFAULT 是不能重入，可以配置成PTHREAD_MTUEX_ERRCHECK用于报错，配置成PTHEAD_MUTEX_NORMAL会死锁，配置成PTHREAD_MUTEX_RECURSIVE 后mutex即是可重入的。同样还有pthread_mutex_timelock用于有限时间的加锁 * pthread_rwlock_t：与mutex类似也有同样的函数用于创建，退出，同样的默认初始化是用一个宏PTHREAD_RWLOCK_INITALIZER来初始化，write-lock是不可重入的，会导致死锁。read-loack是可重入的，但是在pthread的实现中，读者的等级与高于写者的，读者一直拿着，写者需要一直等待所有的读者都释放锁。 * pthread_cont_t: 同样与mutex类似，都是有一系列函数用于创建，销毁，值得一说的是限时的cond是可以配置成使用instance时间还是wall clock。 * 还有pthread_barrier_it，pthread_sping_lock_t 和once类型pthread_once_t\n在rust中包装pthread 包装的时候，因为pthread都是用的地址，与指针强相关，甚至还会有自引用地址，而rust中语义为move，要做到两者的兼容，一个做法是用box包一层:\npub struct Mutex{ m : Box\u0026lt;UnsafeCell\u0026lt;libc::pthread_mutex_t\u0026gt;\u0026gt;; } 在1.62之前的mutex是这么实现的。这样的实现也会带来一些问题，比如访问的开销，无法把mutex的一些函数变成const fn。一个更大的问题是，MutexGarud是可以使用std::mem::forget来提前释放掉的，在一个scope里，如果一个lock先lock，然后mutexguard释放掉了，然后lock在没有Unlock的情况下去释放，这种情况是ub。 ps1（虽然文中没有提到后面是版本是怎么实现的，但是我觉得在有futex的情况下，应该都是用的futex来实现的） ps2:看了一下代码，实现const的方式是用OnceBox包了一层，drop的问题，如果已经lock了要去drop的时候，同样把这个mutex给leak掉。 https://github.com/rust-lang/rust/blob/master/library/std/src/sys/sync/mutex/pthread.rs\nlinux 在Linux上，mutex是用linux提供的一个syscall来实现的，叫SYS_FUTEX。其中包含两个操作，一个是FUTEX_WAIT，一个是FUTEX_WAKE，wait会让线程睡眠，而wake会唤醒。 用futex实现mutex的核心机制是在用户态使用一个atomic变量来表示是否锁住了，当线程A把变量改成1代表持有锁，线程B再去拿的时候，内核会让线程B进入睡眠，然后放入等待队列中，等待唤醒。但是如果可以拿到锁的话，那么就不用进入内核态，大大减少了开销。 rust上的实现如此：https://github.com/rust-lang/rust/blob/master/library/std/src/sys/sync/mutex/futex.rs。\nfutex operations 一般fuex函数有两个参数，一个是watch的atomic i32变量，一个是操作。 一些操作如链接：https://www.man7.org/linux/man-pages/man2/futex.2.html 一些值得一提的是requeue,当多个线程排队时，第一个线程拿到了变量后，将其它线程重新入队等待另一个变量的值。 futex_wake(wait)_bitset，通过mask来指定wait wake，不会引起惊群。另外就是用于实现rwlock的时候，可以用不同的bit来代表reader writer。 FUTEX_PRIVATE_FLAG，代表所有对同一个atomic操作的线程都是同一个进程，不会跨进程操作，在调用的时候，所有的调用都得带上这个flag。 优化级相关：当进程优先级高的进程，等待进程优先级低的进程的时候，这叫优先级反转，而futex的做法是，当低优先级线程持有锁时，它会临时继承等待该锁的最高优先级线程的优先级。 对于内核来说，需要futex将atomic变量设置为线程ID,用低30位。用高位来代表解锁与否。\nmacos mac用的是pthread实现。但是速度比其它unix平台慢跑，原因是它用的是公平锁，先来先得的机制的。后面10.12才推出了非公平锁。\nWindows windows上的mutex叫critical setion，是可重入的。这个比较重。轻量级的有类似于linux的futex叫WaitOnAdress。还有SRW lock。\n其余的同步原语 semaphore semaphore即OS书中学到的PV操作的同步原语，wait操作会把couter减1，而signal操作会会把couter加1，如果wait遇到counter为0的时候，就会被block住，需要等到signal把counter+1才能唤醒另一个线程。实现上，一个实现是，用一个mutex来保护counter，一个convar来做wait和signal的操作，实现对线程的wait和wake操作。在linux上可以用futex来实现，这样只要用到一个atomic的u32即可实现。\nrcu rcu是一个可以用于大量的数据，多读少写的场景写的无锁数据结构，核心思想是在对一个node做修改的时候，copy一个node出去，让它先修改，其它读者会读到老的数据，然后修改完之后，把node再更新掉： 其中最大的问题在于最后一步，如果还有读者在引用老数据的话，需要等所有的读者都不在引用老数据才能释放掉老数据。 linux rcu C++ rcu\n无锁链表 如图所示，这三步操作都可以atomic的完成。值得注意的是，可能会有多个写者来更新插入，要保证只有一个能更新成功。删除一个节点的时候，也有相同的问题，即什么时候才能释放这个节点。可以使用hazerd pointer或者引用计数等技术能实现。 https://lwn.net/Articles/610972/\nQueue-Based Locks 核心思想是，只维护一个atomic pointer，然后指向一个队列，其中指针中没有使用的位，可以用来表示锁的状态。windows里面的slim read write lock就是这么实现的。 ## Parking Lot\u0026ndash;Based Locks parking lot 锁是对queue based lock的优化，可以把mutex优化的尽量小，即mutex只用来表示是否有锁，是否有队列，然后另外一个全局变量hashmap来表示，以adress为key，以queue为value。\nrust中有一个parking_lot就是如此实现的。当然它还有很多优化，优化性能，否则会对hashmpa抢占很严重。\nSequence Lock Sequence lock的思路是在结构中加上一个counter,当写者进行写的时候，把couter变成奇数，写完之后，再把counter变成偶数，所有的读者都可以随便读数据，但是需要比较前后的couter的数值，如果都是偶数且没有变化，则是有效，否则要重试。\nSeqLock\n","permalink":"https://linxy.dev/posts/rust-atomic/","summary":"\u003ch1 id=\"basic-of-rust-concurrency\"\u003ebasic of rust concurrency\u003c/h1\u003e\n\u003cp\u003e内部可变性是指可以通一个不可变引用来实现对内部数据的修改。标准库中有\u003ccode\u003eCell\u0026lt;T\u0026gt;\u003c/code\u003e，Cell相当于持有这个Obj，要做修改只能先把T move出来再把T塞回去。\u003ccode\u003eRefCell\u0026lt;T\u0026gt;\u003c/code\u003e不但持有这个obj，还会维护一个引用计数，如果在运行时有多个Mut借用时，会panic。\u003cbr\u003e\n\u003ccode\u003eRwLock\u003c/code\u003e是多线程版本的\u003ccode\u003eRefCell\u003c/code\u003e，但是多个可变借用时，或者说多个写时，会block住试图拿这个可变借用的线程，让它进入sleep。而\u003ccode\u003eMutex\u003c/code\u003e不像Rwlock可以实现多个可读借用，mutex是彻底的独占的，其它线程都必须等待锁的释放。\u003cbr\u003e\n\u003ccode\u003eUnSafeCell\u003c/code\u003e是实现内部可变性的关键类型，它只有get函数可以得到一个底层类型的raw pointer,\u003ccode\u003eUnsafeCell\u003c/code\u003e没有任何保证安全性的限制，需要用户自己来进行安全性的保证。一般不会直接用unsafe cell，都是包装成另一个类型来限制使用，比如实现成cell或者mutex。\u003cbr\u003e\n\u003ccode\u003eSend\u003c/code\u003etrait意味着这个类型的所有权可以在线程之间转移，\u003ccode\u003eSync\u003c/code\u003etrait意味着这个类型可以在线程之间共享。\u003cbr\u003e\n一个struct如果所有的类型都是send和sync，那它本身也是send和sync的，如果要实现非send和sync的话，可以用phontomdata 标记类型。PhantomData用于标记Struct非sync，毕竟这是个zero sized type。\u003cbr\u003e\n给一些非auto trait实现send和sync是unsafe的，因为取决于其中类型的具体实现，所以安全性需要自己来保证。\u003cbr\u003e\nrust的mutex，实现了一个其它线程如果持有了mutex，但是panic了，这个mutex就是poison的机制：\u003ca href=\"https://doc.rust-lang.org/std/sync/struct.Mutex.html#poisoning\"\u003erust mutex doc\u003c/a\u003e。\nmutex一些值得注意的点:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eif let的scope。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nb\"\u003eSome\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eitem\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elock\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eunwrap\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003epop\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"c1\"\u003e//会lock到这个if结束\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eprocess_item\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eitem\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elock\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eunwrap\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003epop\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e==\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"nb\"\u003eSome\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"c1\"\u003e//在进入body前，MutxGuard就已经drop掉了。\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"w\"\u003e        \u003c/span\u003e\u003cspan class=\"n\"\u003edo_something\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003erust 2024做出的一个if let的小修改，即if let的表达式生命周期不会延长到else body中去：\u003ca href=\"https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html\"\u003erust 2024 doc\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e大多数的读写锁的实现都会block新的读者出现，当写者等待时，因为可能会多个读者共享导致写者一直要等待，这是读写锁中一个经典的饥饿问题。\n## parking and condition variables\n当一个线程在等待别的线程的通知的时候，这种叫thread parking，parking的时候，线程会进入睡眠，唤醒可以用unpark。\n在实现上，unpark有一个很重要的特性是，有一个信号保留机制，即unpark在park之前执行了，这个park也不会让线程进入睡眠，因为消费者需要对生产者的每一个unpark都有响应，否则会有丢数据的风险。\n但是unpark并不能叠加，所以unpark两次后，再Park两次还是会线程进入睡眠。\u003c/p\u003e\n\u003cp\u003e条件变量一般是与mutex结合使用，传入同一个mutex，一个线程wait，一个线程notify。如果两个线程在操作同一个条件变量但是不同的mutex，会引起panic.\u003c/p\u003e\n\u003ch1 id=\"atomic-and-memory-order\"\u003eAtomic and Memory order\u003c/h1\u003e\n\u003cp\u003e原子类型可以在多线程间安全的访问和修改，但是依赖于Memory Ordering。比如最简单的order,Ralex,Relax只能保证单个变量的一致性，而多个变量间顺序无法保证。\natomic i32的溢出是回环的，不像普通的i32，溢出是会panic的。\n为什么需要memory order?CPU会为了优化而把程序中的指令进行重排，写的是什么顺序，执行起来可能是别的顺序。\nHappens before即保证A发生在B之前，但是在多线程中却是不一定的，使用锁可以保证，或者更严格的memory ordering。\u003c/p\u003e","title":"Rust Atomic 笔记"},{"content":"好久没有写过年度总结类的文章了，最大的原因是在年底回忆起来，一年可能什么也没做，实在不太好写；即使写出来也会是充满了悔恨的文字，颇有熬夜之后，临睡之前的悔恨之意。 扯远了，那么2024年做了些啥呢？\n运动 2024年最大的成功就是完成了两场半程马拉松，备赛时间从7月到10月底，刚好四个月。最好成绩是在杭州以1小时43分钟完赛。本来目标应该是跑进140的，但是在10月中的时候，一周无休的情况下，出去骑了100km，导致自己左脚踝受伤了，后面就只能停跑，到11月初参加比赛的时候，有氧水平掉了很多；杭州马拉松跑完的时候，脚真的是疼的不行，休息了一周硬顶上了南昌马拉松，以150完赛，当时感叹一下能完赛就算成功吧。\n在当前时间节点看来，备赛的4个月是我感觉状态最好的时候，睡眠质量好，吃的也多，爬山也很轻松。多运动确实有好处吧。骑车今年骑的不多了，因为秋天转跑步了，所以后面都只是穿插了一下骑行活动，但是今年依旧跑了1000公里，骑了2000公里。 25年的目标就是以330完赛全马吧，虽然现在一个比赛都没中过，也没开始备赛。\n书 今年读了43本书，大多是推理小说与读库，还有一些文学类的，举几本印象深刻的。\n《流俗地》，年初读的，读了之后就感叹道肯定是个人24年TOP1的书，文笔无可挑剔。也算是为我打了南洋文学的一扇门吧。 《罪与罚》，年尾读的，读完后感觉陀爷真是神人，对杀人这件事的心理描写拿捏的如此精准，可见一定杀过人。 《悉达多》，主角宛如圣人一般的寓言故事。 《雾切7》，我们在群里多次提到了雾切，只能说这作的开篇和结尾确实花了心思，也是写的最好的。 游戏 今年唯一打完的单机游戏是baldr sky，好多游戏只打了个开篇就没有玩了。其中的原因是有些游戏后面是个悲剧，我不太愿意面对。有些是我人太浮躁，玩不太下去。开了很多游戏坑，还是得沉下心来好好体验这些游戏啊。 一句话总结就是上半年大多数时间在打雀魂，下半年跑步几乎不打游戏，12月在打CS。\n剧与动漫与电影 今年看了不少剧，看的好电影也不少，提一些印象深刻的\n《我的天才女友》123季都看完了，第4季看了一半，前面123季拍的真很好，让我感觉老意大利真的美。 《好东西》，算是年度好电影了吧，我看完的体验是到底谁在急眼呢，很多人都急眼了，感觉被攻击的是自己，可是电影中并没有攻击别人。电影更多的是表现女性生活，可以说并不止步女性的生活。 《因果报应》，应该是我的年度悬疑电影吧。即便是印度电影，仍然体现的是女性主义的核心。 《恶魔的破坏》，虽然还没有看完，但是值得我写一笔，动画体现的是日本的一种真实，而这些真实正在被消费，我感觉很诡异，但是实际上这种真实就是用来消费了，消费了才能有反馈啊。 《异形》，retro风格的电影，镜头挺有讲究的，算是看的爽的一类电影。 《JOJO5》，算是星尘十字军之后最好的一部吧，布姐的精神最好的诠释了黄金之风。 《葬送的芙莉莲》，应该算我的年度动漫，制作好，音乐好听，周指活。 《请回答1988》，18年开始看的，终于在今年看完了。几度看泪目了，时代与群像剧的TOP1吧。另外提一嘴《小巷人家》，本来能超越1988，可惜前8集能看。 技术 今年尝试给Rust Analyzer提了几个PR，给apache下面的项目做了贡献，虽然都是些小小的，但是至少跨出了自己做开源的第一步，打破了自己心目中神化了提开源PR这么一件事的印象。其实大多数项目都一样，只是草台程度不同的区别。\nRust方面读了Rust Atomic（这是本好书），然后拿Rust写了一个私活项目，可能也有几万行吧，算是实践的部分。另外这个项目还有客户端部分，写了一个月的avalonio，感觉写GUI体验真不太好，只能说GUI的editor跟游戏的editor都一样，真要做的好用，确实太难了。\n另外读了几本技术书，但是感觉都一般，就不提了。 可见25年还是得多写多读，不能再懈怠了。\n生活 今年9月买了一辆车，极大的扩大了行动的范围，虽然因为我们太宅，没有太出去走，但是至少多了一个出行的选择。\n家里三只猫，两只在年初的时候治好了病毒性口炎，也就年中的时候小猫肠胃炎去了一次医院，相对来说，猫仔的生活也算是很好了。\n去了一次胡彦斌的演唱会，爽听了三小时，也算是值回了票价了。\n去了一次初音的演唱会，体验了一下打call，虽然中文歌有点多，但是体验仍是不错的，可能这就是二次元吧。\n总结 24年当时定下的目标其实很简单，就是走出舒适区，多去体验体验生活，现在来看，基本完成了目标了；体验了很多之前没有干过的事，看过不少自己以前没有看过的电影，剧的类型。 那么展望25年，25年的目标就是技术上精进一步，搞一个side project试试，游戏上打完海猫与BG3，十三机兵，阅读上一定要读完的是陀爷的书；运动上330完赛全马。\n","permalink":"https://linxy.dev/posts/2024/","summary":"\u003cp\u003e好久没有写过年度总结类的文章了，最大的原因是在年底回忆起来，一年可能什么也没做，实在不太好写；即使写出来也会是充满了悔恨的文字，颇有熬夜之后，临睡之前的悔恨之意。\n扯远了，那么2024年做了些啥呢？\u003c/p\u003e\n\u003ch2 id=\"运动\"\u003e运动\u003c/h2\u003e\n\u003cp\u003e2024年最大的成功就是完成了两场半程马拉松，备赛时间从7月到10月底，刚好四个月。最好成绩是在杭州以1小时43分钟完赛。本来目标应该是跑进140的，但是在10月中的时候，一周无休的情况下，出去骑了100km，导致自己左脚踝受伤了，后面就只能停跑，到11月初参加比赛的时候，有氧水平掉了很多；杭州马拉松跑完的时候，脚真的是疼的不行，休息了一周硬顶上了南昌马拉松，以150完赛，当时感叹一下能完赛就算成功吧。\u003cbr\u003e\n在当前时间节点看来，备赛的4个月是我感觉状态最好的时候，睡眠质量好，吃的也多，爬山也很轻松。多运动确实有好处吧。骑车今年骑的不多了，因为秋天转跑步了，所以后面都只是穿插了一下骑行活动，但是今年依旧跑了1000公里，骑了2000公里。\n25年的目标就是以330完赛全马吧，虽然现在一个比赛都没中过，也没开始备赛。\u003c/p\u003e\n\u003ch2 id=\"书\"\u003e书\u003c/h2\u003e\n\u003cp\u003e今年读了43本书，大多是推理小说与读库，还有一些文学类的，举几本印象深刻的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e《流俗地》，年初读的，读了之后就感叹道肯定是个人24年TOP1的书，文笔无可挑剔。也算是为我打了南洋文学的一扇门吧。\u003c/li\u003e\n\u003cli\u003e《罪与罚》，年尾读的，读完后感觉陀爷真是神人，对杀人这件事的心理描写拿捏的如此精准，可见一定杀过人。\u003c/li\u003e\n\u003cli\u003e《悉达多》，主角宛如圣人一般的寓言故事。\u003c/li\u003e\n\u003cli\u003e《雾切7》，我们在群里多次提到了雾切，只能说这作的开篇和结尾确实花了心思，也是写的最好的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"游戏\"\u003e游戏\u003c/h2\u003e\n\u003cp\u003e今年唯一打完的单机游戏是baldr sky，好多游戏只打了个开篇就没有玩了。其中的原因是有些游戏后面是个悲剧，我不太愿意面对。有些是我人太浮躁，玩不太下去。开了很多游戏坑，还是得沉下心来好好体验这些游戏啊。\n一句话总结就是上半年大多数时间在打雀魂，下半年跑步几乎不打游戏，12月在打CS。\u003c/p\u003e\n\u003ch2 id=\"剧与动漫与电影\"\u003e剧与动漫与电影\u003c/h2\u003e\n\u003cp\u003e今年看了不少剧，看的好电影也不少，提一些印象深刻的\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e《我的天才女友》123季都看完了，第4季看了一半，前面123季拍的真很好，让我感觉老意大利真的美。\u003c/li\u003e\n\u003cli\u003e《好东西》，算是年度好电影了吧，我看完的体验是到底谁在急眼呢，很多人都急眼了，感觉被攻击的是自己，可是电影中并没有攻击别人。电影更多的是表现女性生活，可以说并不止步女性的生活。\u003c/li\u003e\n\u003cli\u003e《因果报应》，应该是我的年度悬疑电影吧。即便是印度电影，仍然体现的是女性主义的核心。\u003c/li\u003e\n\u003cli\u003e《恶魔的破坏》，虽然还没有看完，但是值得我写一笔，动画体现的是日本的一种真实，而这些真实正在被消费，我感觉很诡异，但是实际上这种真实就是用来消费了，消费了才能有反馈啊。\u003c/li\u003e\n\u003cli\u003e《异形》，retro风格的电影，镜头挺有讲究的，算是看的爽的一类电影。\u003c/li\u003e\n\u003cli\u003e《JOJO5》，算是星尘十字军之后最好的一部吧，布姐的精神最好的诠释了黄金之风。\u003c/li\u003e\n\u003cli\u003e《葬送的芙莉莲》，应该算我的年度动漫，制作好，音乐好听，周指活。\u003c/li\u003e\n\u003cli\u003e《请回答1988》，18年开始看的，终于在今年看完了。几度看泪目了，时代与群像剧的TOP1吧。另外提一嘴《小巷人家》，本来能超越1988，可惜前8集能看。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"技术\"\u003e技术\u003c/h2\u003e\n\u003cp\u003e今年尝试给Rust Analyzer提了几个PR，给apache下面的项目做了贡献，虽然都是些小小的，但是至少跨出了自己做开源的第一步，打破了自己心目中神化了提开源PR这么一件事的印象。其实大多数项目都一样，只是草台程度不同的区别。\u003cbr\u003e\nRust方面读了Rust Atomic（这是本好书），然后拿Rust写了一个私活项目，可能也有几万行吧，算是实践的部分。另外这个项目还有客户端部分，写了一个月的avalonio，感觉写GUI体验真不太好，只能说GUI的editor跟游戏的editor都一样，真要做的好用，确实太难了。\u003cbr\u003e\n另外读了几本技术书，但是感觉都一般，就不提了。\n可见25年还是得多写多读，不能再懈怠了。\u003c/p\u003e\n\u003ch2 id=\"生活\"\u003e生活\u003c/h2\u003e\n\u003cp\u003e今年9月买了一辆车，极大的扩大了行动的范围，虽然因为我们太宅，没有太出去走，但是至少多了一个出行的选择。\u003cbr\u003e\n家里三只猫，两只在年初的时候治好了病毒性口炎，也就年中的时候小猫肠胃炎去了一次医院，相对来说，猫仔的生活也算是很好了。\u003cbr\u003e\n去了一次胡彦斌的演唱会，爽听了三小时，也算是值回了票价了。\u003cbr\u003e\n去了一次初音的演唱会，体验了一下打call，虽然中文歌有点多，但是体验仍是不错的，可能这就是二次元吧。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\n\u003cp\u003e24年当时定下的目标其实很简单，就是走出舒适区，多去体验体验生活，现在来看，基本完成了目标了；体验了很多之前没有干过的事，看过不少自己以前没有看过的电影，剧的类型。\n那么展望25年，25年的目标就是技术上精进一步，搞一个side project试试，游戏上打完海猫与BG3，十三机兵，阅读上一定要读完的是陀爷的书；运动上330完赛全马。\u003c/p\u003e","title":"2024总结"},{"content":" 去年这时候，mwish 推荐给我一个galgame:Baldr Sky,我一直以来对galgame是不太感冒的，总感觉是与色色有关的游戏，而在游戏中寻找这种元素似乎是一件比较蠢的事；另外一个原因是，在我的认知中，一个黄油很难会有什么好的人物塑造，上来就推倒这种剧情显的很傻。而baldr sky是一个颠覆了我对galgame认知的作品，剧情音乐战斗都是超一流的优秀，而H的部分在这些看来真的很显的多余。\n蕾线\n作为开篇的线，本线做的非常好，玩家刚上手游戏，并不知道这个世界是怎么样的，而主人公甲在剧情中也是失忆状态的，所有的世界观与剧情都会随着记忆的恢复慢慢展开给玩家。不知道是不是故意而为之，制作组把蕾这样的一个人物放在最前面的，让后面的线推的时候，很难无视掉rain的付出，从而更加加深了对蕾的印象。蕾的人物塑造也非常鲜活，战场上给甲爷辅助，生活上给甲爷如同贤内助一般的照顾，可以说蕾是最完美的忠犬。在后面的线中，蕾无法作为女主出现在主流剧情中，但是仍然表现出来了对甲的忠诚，对甲隐藏的爱，这让我感觉非常的对不起她，难怪蕾是人气最高的角色。蕾线的Good ending是甲爷跟蕾远走高飞，过上了幸福的生活，可以说是非常甜的结局了，如果故事只限于此，而它将是平庸的作品。\n菜叶线\n菜叶线我印象最深的是结局中那个浪漫的场景，菜叶线紧接着蕾线，慢慢的把这个世界发生的事更加细化的展开来，让玩家发现这个世界不只是简单的一条故事线那么简单，总会有人死去。菜叶是一个非常可怜的女孩子，对老师充满了信任，最后却被利用了，不过我感觉这条线的情感有点牵强。在这条线中的千夏死掉了，从而引出了千夏线。\n千夏线\n我对千夏线只有愤怒，千夏塑造的非常好，学生时期的乐观与直球都是在隐藏自己，到后面发现了自己目标，哪怕让自己死也要达成目标。但是，这条线的甲爷塑造的太失败了，居然为了千夏大杀特杀，手刃蕾与魔狼的人，这对我来说简直不理喻，甲爷不是这样一个角色，为了爱情可以抛弃所有的人啊。千夏惨也是真的惨，千夏线她能得到幸福也是应该的。但是最后居然住到了Rain家里，这特么是什么鬼？还要在她家做。真是见鬼。\n亚季线\n我个人觉得亚季线真的是编剧写的最好的一条线，主要是在情感上被编剧牵着走，对于是不是乱伦这个问题，我感觉我的心情在过山车，而编剧用了好几层诡叙来震撼玩家。而亚季与情感线在我看来也比千夏与菜叶来的更加自然。\n真线\n真线其实我感觉更多的像是工具人线一般，因为情感上似乎也不是很能自恰，要说喜欢，我觉得真最多只是崇拜吧，而真因为一个恶作剧让自己承担上了无比沉重的责任，这样的写法让真这个角色更加有血有肉了。\n空线\n个人觉得空线其实写的挺一般，主要是文本量摆在那，但是要做的事情太多了，前面还要插进去一些救回各个女主，有些太过于冗长，如果更多的笔墨分到与空的情感交互上就更好了。不过空线作为收篇线，后半段非常的好，一个燃系机甲游戏，大甲收到各个世界线的甲的信念与记忆后，大喊Dr19，终结这一切吧后，BGM响起，与Dr19的战斗开始了，情感在这一刻到达了最顶峰，千千万万场战斗，最终都是为了救空，而空也独自撑了千万年。打完了Dr19后，我感觉到一丝解脱，终于结束了，终于救回了空。\njihad与沉默之空的音乐也为本作增色许多，在与千夏的战斗中，响起了BGM之时，真是太带感了。\n战斗系统简约但不简单，也是到后期我才开发出一套连招可以输出很高，才在决战之时不那么痛苦，但是空线的战斗实在太多了，有些战斗真的又臭又长了。最后的True ending我也没有再打了，只能云一下了。\n长达69小时的游玩，只能说这游戏确实是神作。\n一些缺点：游戏不能放其它盘，容易闪退，而空线闪退频率太高了，好多战斗我都打了好多遍。\n个人喜好线：空线=亚季线=rain线 \u0026gt; 菜叶线 \u0026gt; 真线 \u0026gt; 千夏线\n个人女主喜好：蕾 = 空 \u0026gt; 千夏 \u0026gt; 亚季 \u0026gt; 真 \u0026gt; 菜叶。\n","permalink":"https://linxy.dev/posts/baldr-sky/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/baldr_sky.png\"\u003e\n去年这时候，\u003ca href=\"https://blog.mwish.me\"\u003emwish\u003c/a\u003e 推荐给我一个galgame:Baldr Sky,我一直以来对galgame是不太感冒的，总感觉是与色色有关的游戏，而在游戏中寻找这种元素似乎是一件比较蠢的事；另外一个原因是，在我的认知中，一个黄油很难会有什么好的人物塑造，上来就推倒这种剧情显的很傻。而baldr sky是一个颠覆了我对galgame认知的作品，剧情音乐战斗都是超一流的优秀，而H的部分在这些看来真的很显的多余。\u003c/p\u003e\n\u003cp\u003e蕾线\u003cbr\u003e\n作为开篇的线，本线做的非常好，玩家刚上手游戏，并不知道这个世界是怎么样的，而主人公甲在剧情中也是失忆状态的，所有的世界观与剧情都会随着记忆的恢复慢慢展开给玩家。不知道是不是故意而为之，制作组把蕾这样的一个人物放在最前面的，让后面的线推的时候，很难无视掉rain的付出，从而更加加深了对蕾的印象。蕾的人物塑造也非常鲜活，战场上给甲爷辅助，生活上给甲爷如同贤内助一般的照顾，可以说蕾是最完美的忠犬。在后面的线中，蕾无法作为女主出现在主流剧情中，但是仍然表现出来了对甲的忠诚，对甲隐藏的爱，这让我感觉非常的对不起她，难怪蕾是人气最高的角色。蕾线的Good ending是甲爷跟蕾远走高飞，过上了幸福的生活，可以说是非常甜的结局了，如果故事只限于此，而它将是平庸的作品。\u003cbr\u003e\n菜叶线\u003cbr\u003e\n菜叶线我印象最深的是结局中那个浪漫的场景，菜叶线紧接着蕾线，慢慢的把这个世界发生的事更加细化的展开来，让玩家发现这个世界不只是简单的一条故事线那么简单，总会有人死去。菜叶是一个非常可怜的女孩子，对老师充满了信任，最后却被利用了，不过我感觉这条线的情感有点牵强。在这条线中的千夏死掉了，从而引出了千夏线。\u003cbr\u003e\n千夏线\u003cbr\u003e\n我对千夏线只有愤怒，千夏塑造的非常好，学生时期的乐观与直球都是在隐藏自己，到后面发现了自己目标，哪怕让自己死也要达成目标。但是，这条线的甲爷塑造的太失败了，居然为了千夏大杀特杀，手刃蕾与魔狼的人，这对我来说简直不理喻，甲爷不是这样一个角色，为了爱情可以抛弃所有的人啊。千夏惨也是真的惨，千夏线她能得到幸福也是应该的。但是最后居然住到了Rain家里，这特么是什么鬼？还要在她家做。真是见鬼。\u003cbr\u003e\n亚季线\u003cbr\u003e\n我个人觉得亚季线真的是编剧写的最好的一条线，主要是在情感上被编剧牵着走，对于是不是乱伦这个问题，我感觉我的心情在过山车，而编剧用了好几层诡叙来震撼玩家。而亚季与情感线在我看来也比千夏与菜叶来的更加自然。\u003cbr\u003e\n真线\u003cbr\u003e\n真线其实我感觉更多的像是工具人线一般，因为情感上似乎也不是很能自恰，要说喜欢，我觉得真最多只是崇拜吧，而真因为一个恶作剧让自己承担上了无比沉重的责任，这样的写法让真这个角色更加有血有肉了。\u003cbr\u003e\n空线\u003cbr\u003e\n个人觉得空线其实写的挺一般，主要是文本量摆在那，但是要做的事情太多了，前面还要插进去一些救回各个女主，有些太过于冗长，如果更多的笔墨分到与空的情感交互上就更好了。不过空线作为收篇线，后半段非常的好，一个燃系机甲游戏，大甲收到各个世界线的甲的信念与记忆后，大喊Dr19，终结这一切吧后，BGM响起，与Dr19的战斗开始了，情感在这一刻到达了最顶峰，千千万万场战斗，最终都是为了救空，而空也独自撑了千万年。打完了Dr19后，我感觉到一丝解脱，终于结束了，终于救回了空。\u003c/p\u003e\n\u003cp\u003ejihad与沉默之空的音乐也为本作增色许多，在与千夏的战斗中，响起了BGM之时，真是太带感了。\u003cbr\u003e\n战斗系统简约但不简单，也是到后期我才开发出一套连招可以输出很高，才在决战之时不那么痛苦，但是空线的战斗实在太多了，有些战斗真的又臭又长了。最后的True ending我也没有再打了，只能云一下了。\u003c/p\u003e\n\u003cp\u003e长达69小时的游玩，只能说这游戏确实是神作。\u003c/p\u003e\n\u003cp\u003e一些缺点：游戏不能放其它盘，容易闪退，而空线闪退频率太高了，好多战斗我都打了好多遍。\u003c/p\u003e\n\u003cp\u003e个人喜好线：空线=亚季线=rain线 \u0026gt; 菜叶线 \u0026gt; 真线 \u0026gt; 千夏线\u003cbr\u003e\n个人女主喜好：蕾 = 空 \u0026gt; 千夏 \u0026gt; 亚季 \u0026gt; 真 \u0026gt; 菜叶。\u003c/p\u003e","title":"终结这一切吧！Baldr Sky游玩感受"},{"content":"前言 最近把系统换成了CachyOS，用上了ZFS，这个发行版做的一些Tricky还是可以的，例如一些fish的脚本，还有软件与DE的自定义项都比较简洁，比ArcoLinux强上不少。\n我的情况是有两块NVMe的硬盘，一块是Windows系统，一块则是CachyOS。我的期望是用Linux Boot Manager去引导两个操作系统，比用Windows Boot Manager去引导Linux要好操作不少。\n确定fs alias 看了一下systemd-boot的文档，需要先安装 edk2-shell 来给systemd-boot 加个EFI shell:\nsudo pacman -S edk2-shell \u0026amp;\u0026amp; cp /usr/share/edk2-shell/x64/Shell.efi /boot/shellx64.efi 然后在boot的时候选择EFI Shell，在shell中，输入map命令，可以得到所有盘的fs alias, 这里我们需要得到是另一块盘的EFI分区。\n可以用blkid可以看到所有盘or分区的PARTUUID，在EFI shell的map命令的输出结果中，可以对应上具体的fs alias是哪个盘。\n加上Boot脚本 确定了fs alias后就好办了，在/boot/下面新建一个windows.nsh，内容如下：\nHD0b:EFI\\Microsoft\\Boot\\Bootmgfw.efi 在这里，我的windows EFI分区的fs alias是HD0b。\n然后在/boot/loader/entries/下面新建一个引导项windows.conf：\ntitle Windows efi /shellx64.efi options -nointerrupt -noconsolein -noconsoleout windows.nsh 最后检查一下windows.nsh是否在/boot/目录下面，用bootctl list 看一下boot项的输出，我的输出如下：\ntype: Boot Loader Specification Type #1 (.conf) title: Windows id: windows.conf source: /boot//loader/entries/windows.conf efi: /boot//shellx64.efi options: -nointerrupt -noconsolein -noconsoleout windows.nsh type: Boot Loader Specification Type #1 (.conf) title: Linux Cachyos Lts Lto (default) (selected) id: linux-cachyos-lts-lto.conf source: /boot//loader/entries/linux-cachyos-lts-lto.conf linux: /boot//vmlinuz-linux-cachyos-lts-lto initrd: /boot//amd-ucode.img /boot//initramfs-linux-cachyos-lts-lto.img options: zfs=zpcachyos/ROOT/cos/root rw zswap.enabled=0 nowatchdog type: Boot Loader Specification Type #1 (.conf) title: Linux Cachyos Lts Lto (Fallback) id: linux-cachyos-lts-lto-fallback.conf source: /boot//loader/entries/linux-cachyos-lts-lto-fallback.conf linux: /boot//vmlinuz-linux-cachyos-lts-lto initrd: /boot//amd-ucode.img /boot//initramfs-linux-cachyos-lts-lto-fallback.img options: zfs=zpcachyos/ROOT/cos/root rw 可以确定的是，如果输出正确，那么就可以在引导的时候选择windows了。 PS，如果要改默认选择项，在/boot/loader/loader.conf 中可以改掉默认引导项，或者使用bootctl set-default 来指定。\n添加Hook自动生成 2023-11-16更新：\n上述方案有个问题，如果每更新内核的话，entryies目录下的配置文件会被清空，所以需要有一个机制让内核更新的时候也能把windows.conf复制进去。\n这里我选择的是，新建一个service，新建一个pacman的hook，每次在内核更新的时候，会触发hook，然后启动service，将处于其它路径中的配置文件复制到boot分区中去。\n方法如下：\n在非boot目录放置上述两个文件:windows.nsh 与windows.conf。这里我选择的目录是~/conf; 在/etc/systemd/system/下面新建一个update-windows-boot.service ： [Unit] Description=Update Windows boot entry [Service] ExecStart=/usr/bin/update-windows-entry.sh 在/usr/bin/下面新建update-windows-entry.sh，别忘记chmod +x 加上权限: #!/bin/bash cp /home/linxy/conf/windows.nsh /boot/ cp /home/linxy/conf/windows.conf /boot/loader/entries/ 在/etc/pacman.d/hooks下面新建update-windows-entry.hook: [Trigger] Operation = Upgrade Type = Package Target = linux-cachyos Target = linux-cachyos-lts Target = linux-lts Target = linux [Action] Description = Updating Windows boot entry... When = PostTransaction Exec = /usr/bin/systemctl start update-windows-boot.service 其中，target指的就是升级什么包的时候会触发这个hook。配置完成后，即可以在每次升级内核的时候保持windows的boot项。\nTODO：也许可以把service去掉，直接执行脚本。有时间再研究吧\n","permalink":"https://linxy.dev/posts/systemd-boot-windows/","summary":"\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e最近把系统换成了CachyOS，用上了ZFS，这个发行版做的一些Tricky还是可以的，例如一些fish的脚本，还有软件与DE的自定义项都比较简洁，比ArcoLinux强上不少。\u003cbr\u003e\n我的情况是有两块NVMe的硬盘，一块是Windows系统，一块则是CachyOS。我的期望是用Linux Boot Manager去引导两个操作系统，比用Windows Boot Manager去引导Linux要好操作不少。\u003c/p\u003e","title":"systemd-boot添加Windows引导项"},{"content":"raft基础 一个raft集群一般来说有5个服务器结点，能让系统承受其中任意两台的down掉。每个服务器一共有三个状态，leader,follower,candidate,follower被动的接受来自candidate与leader的消息并作出回应。leader handle了所有了所有的客户端的请求，如果follower接收到了请求，会重定向到leader那去。\nraft把时间分成任意长的阶段，从选举开始，每个阶段都是一个连续增长的整数，至少有一个或者多个candidate会尝试成为leader。如果有一个candidate成为了leader，则接下来的term，它将是leader。在一些情况下，选举会出现，平分票数的情况，这种情况，term将会维持没有leader的状态到结束，到下一次的新的选举。\n不同的服务器 可能感知不到不同的term之间的转换，或者根本不知道有选举这回事，在这其中，term充当了一个逻辑时钟的作用，能让服务器能检测过时的信息，比如落后的leader。每一个服务器有一个current term number，随着时间增长，当服务器之间通信时，current term 会被 交换，如果有一个服务器的term小于别的，就会更新自己的，如果一个canditate或者leader发现它自己的term过时了，就会马上转变成follower，如果服务器收到了一个过时的请求，则会直接拒绝这个请求。\nraft的服务器之间用rpc请行通信，其中RequestVote用于canditate 来进行选举，AppendEntries 用于分发log与当心跳包（事实上是无论收到一个请求，都应该重置time out chekcer）。另外 还有一个转移快照的rpc。之后 再说。\n选举 raft使用心跳机制来触发选举。当服务器启动的时候，它们都是follower，follower在收到来自leader或者 candidate合法的rpc请求之前，一直是follower，leader会周期性的发送心跳包来保持leader的权威性，心跳包是一个空的AppendEntries，不带有Log entries。当一个follower一个election timeout后没有收到心跳包，则认为leader没了，将开始一轮选举，选出一个新的leader。\n为了开始一次选举，follower会给current term+1然后转变成candidate，然后投自己一票，然后同时发起RequestVote RPC给别的服务器。一个candidate会持续到以下三件情况出现，(a)它成了leader，(b)其它服务器成了leader(c)一段时间过去后，没有server成为leader。这将在之后讨论（应该是过一段时间重新发起）\n一个candidate如果收到了整个集群中大多数的投票 (with same term)，就会成为leader。每一个服务器最多只能投出一票。这个大多数 的规则决定了，在一个term里，只能一个candidate成为leader。一旦candidate成为了leader，则会开始发送心跳包给其它所有的服务器，来保证自己的权威与阻止其它服务器发起选举。\n在投票的过程中，可能 会收到来其它服务器发来的AppendEntries RPC来声称自己是leader，这种情况，看leader的term与自己的current term的大小，如果比自己大，那别人就是leader，自己将退回到follower的状态，如果比自己小，就是拒绝别人的RPC call，并继续进行选举。\n一个选举如果选不出一个leader那就是分裂的选举，即没人得到大多数票，这种情况下，会等待超时直到下一次的选举，但是如果 没有做额外的操作，分裂的选举会不停的进行下去。\nraft采用了随机的选举超时来保证split vote是很少见的并且能快速的被解决。即每一个服务器的election timeout不一样，在重新发起选举的之前会等待这个timeout，timeout少的会先发起选举。一般的timeout会选择一个区间比如150-300ms之间。这样会有一个服务器超时完成并在别的服务器节点超时完成前完成选举。\nLog replication 一旦一个leader被选举，那它就开始接受client的请求，每一个client的请求都包含一个命令，这个命令会被 replicated state machines执行，leader将会把这个command append到日志中去，作为一个新的entry，然后用AppendEntries 分发到其它的服务器。 leader会永远的尝试去写入follower log entry，直到所有的log entry都被 写入。\nleader决定什么时候日志被 commit，当大多数的服务器都复制了一份entry后，就会提交，也会提前之前的entries，论文中设计了两个重要的属性\n如果不同日志中的两个Entry有一样的index跟term，那他们存的一个东西 如果不同日志中的两个entry有一样的index跟term，那他们之前的所有entry是相同的。 属性1保证了，在给定的term与index中只会创建一个entry，属性2保证了一致性的简单性。\n如果follower发现leader发过来的index跟term在自己的log里没有，那么会拒绝这个新的entry。（因为在消息中包含了这条新的之前的index跟term，所以可以检测之前的一致性，如果之前的都不一致就根本不会append这个新的）\n在Raft中，处理leader与follower的不一致性是通过强制把leader的log记录复制给follower来完成的，这意味着follower的log的冲突部分，会被完全覆盖。\n为了使follwer的log保持一致，leader必须找到leader与follwer最近的一个一样的entry，然后把这个之后的log都发给follower。\nleader对于每一个follower都维护了一个index，这个index是leader将要发给follower的下一个index，当一个leader上台后， 会把这个next index初始化为自己log中的最后一个index，如果有follower的记录与leader不一致，那么在下一次Append Entries RPC的一致性检查中失败。当这个调用失败后，leader将决定下一个next index是多少，最终，next index会在重试中到达leader与follower一致的地方。当RPC调用成功之后，leader会把之后的记录全发给follower，这样就follower就完成了与leader的一致性同步。\nleader永远不会改自己的log。这是强保证。\n强约束 为了达成算法的强一致性，必须加上一些强约束。\n选举 RPC必须包含candidate的log，然后投票者看canditate的log是否比自己的旧，如果旧，则会拒绝投给它，这样会保证选举出来的leader跟大多数的投票者中的log是一致的。\n非提交的entry raft不会提交之前阶段的非提交的entry。对于raft来说，如果leader当前的entry提交了，其中的潜在的语义包含了之前的entry都是提交了的。\n安全性争论 这部分主要是证明future term的log是 一定包含了之前term的提交的，因为如果没提交的话，会有两个矛盾，第一，它成为不了leader，第二，它的entry log一定比之前的要大。原文中用的反证法，说term U没有包含term T的 log。实际上，在投票的时候 它成为不了leader，另外一个就是假如它是leader，它的log也得包含之前的，不然提交不了到follower。\n崩溃 如果follower或者candidate崩溃了，leader会一直发请求，直到成功，如果follower在commit log之后但是没有回复，之后重启了，发现收到了同样index的entry写入请求，会忽视这个请求。\n时间与可用性 raft的安全性不应该依赖时间：系统不应该因为一些事件发生的比预期的慢或者快就产生错误的结果。然而可用性却是不可避免的依赖时间。例如，因为如果回复慢了，follower就要变成candidate了。\n其中leader election是raft中对时间最敏感的。raft将会选出一个稳定的leader，且这个系统满足这样的延迟要求：broadcastTime \u0026lt; electionTimout \u0026lt; MTBF。\n广播时间应该要比选举超时少一个数量级，而选举时间应该要比恢复时间要少几个数量级。这样当leader崩溃的时候，也只有选举时间内不可用而已。\n通常来说broadcasttim从0.5ms到20ms不等，而选举超时从10 ms 到500ms不等。而mtbf几个月。\n","permalink":"https://linxy.dev/posts/raft-notes/","summary":"\u003ch1 id=\"raft基础\"\u003eraft基础\u003c/h1\u003e\n\u003cp\u003e一个raft集群一般来说有5个服务器结点，能让系统承受其中任意两台的down掉。每个服务器一共有三个状态，leader,follower,candidate,follower被动的接受来自candidate与leader的消息并作出回应。leader handle了所有了所有的客户端的请求，如果follower接收到了请求，会重定向到leader那去。\u003c/p\u003e\n\u003cp\u003eraft把时间分成任意长的阶段，从选举开始，每个阶段都是一个连续增长的整数，至少有一个或者多个candidate会尝试成为leader。如果有一个candidate成为了leader，则接下来的term，它将是leader。在一些情况下，选举会出现，平分票数的情况，这种情况，term将会维持没有leader的状态到结束，到下一次的新的选举。\u003c/p\u003e\n\u003cp\u003e不同的服务器 可能感知不到不同的term之间的转换，或者根本不知道有选举这回事，在这其中，term充当了一个逻辑时钟的作用，能让服务器能检测过时的信息，比如落后的leader。每一个服务器有一个current term number，随着时间增长，当服务器之间通信时，current term 会被 交换，如果有一个服务器的term小于别的，就会更新自己的，如果一个canditate或者leader发现它自己的term过时了，就会马上转变成follower，如果服务器收到了一个过时的请求，则会直接拒绝这个请求。\u003c/p\u003e\n\u003cp\u003eraft的服务器之间用rpc请行通信，其中RequestVote用于canditate 来进行选举，AppendEntries 用于分发log与当心跳包（事实上是无论收到一个请求，都应该重置time out chekcer）。另外 还有一个转移快照的rpc。之后 再说。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch1 id=\"选举\"\u003e选举\u003c/h1\u003e\n\u003cp\u003eraft使用心跳机制来触发选举。当服务器启动的时候，它们都是follower，follower在收到来自leader或者 candidate合法的rpc请求之前，一直是follower，leader会周期性的发送心跳包来保持leader的权威性，心跳包是一个空的AppendEntries，不带有Log entries。当一个follower一个election timeout后没有收到心跳包，则认为leader没了，将开始一轮选举，选出一个新的leader。\u003c/p\u003e\n\u003cp\u003e为了开始一次选举，follower会给current term+1然后转变成candidate，然后投自己一票，然后同时发起RequestVote RPC给别的服务器。一个candidate会持续到以下三件情况出现，(a)它成了leader，(b)其它服务器成了leader(c)一段时间过去后，没有server成为leader。这将在之后讨论（应该是过一段时间重新发起）\u003c/p\u003e\n\u003cp\u003e一个candidate如果收到了整个集群中大多数的投票 (with same term)，就会成为leader。每一个服务器最多只能投出一票。这个\u003ccode\u003e大多数\u003c/code\u003e 的规则决定了，在一个term里，只能一个candidate成为leader。一旦candidate成为了leader，则会开始发送心跳包给其它所有的服务器，来保证自己的权威与阻止其它服务器发起选举。\u003c/p\u003e\n\u003cp\u003e在投票的过程中，可能 会收到来其它服务器发来的AppendEntries RPC来声称自己是leader，这种情况，看leader的term与自己的current term的大小，如果比自己大，那别人就是leader，自己将退回到follower的状态，如果比自己小，就是拒绝别人的RPC call，并继续进行选举。\u003c/p\u003e\n\u003cp\u003e一个选举如果选不出一个leader那就是分裂的选举，即没人得到大多数票，这种情况下，会等待超时直到下一次的选举，但是如果 没有做额外的操作，分裂的选举会不停的进行下去。\u003c/p\u003e\n\u003cp\u003eraft采用了随机的选举超时来保证split vote是很少见的并且能快速的被解决。即每一个服务器的election timeout不一样，在重新发起选举的之前会等待这个timeout，timeout少的会先发起选举。一般的timeout会选择一个区间比如150-300ms之间。这样会有一个服务器超时完成并在别的服务器节点超时完成前完成选举。\u003c/p\u003e\n\u003ch1 id=\"log-replication\"\u003eLog replication\u003c/h1\u003e\n\u003cp\u003e一旦一个leader被选举，那它就开始接受client的请求，每一个client的请求都包含一个命令，这个命令会被 replicated state machines执行，leader将会把这个command append到日志中去，作为一个新的entry，然后用AppendEntries 分发到其它的服务器。 leader会永远的尝试去写入follower log entry，直到所有的log entry都被 写入。\u003c/p\u003e\n\u003cp\u003eleader决定什么时候日志被 commit，当大多数的服务器都复制了一份entry后，就会提交，也会提前之前的entries，论文中设计了两个重要的属性\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果不同日志中的两个Entry有一样的index跟term，那他们存的一个东西\u003c/li\u003e\n\u003cli\u003e如果不同日志中的两个entry有一样的index跟term，那他们之前的所有entry是相同的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e属性1保证了，在给定的term与index中只会创建一个entry，属性2保证了一致性的简单性。\u003c/p\u003e\n\u003cp\u003e如果follower发现leader发过来的index跟term在自己的log里没有，那么会拒绝这个新的entry。（因为在消息中包含了这条新的之前的index跟term，所以可以检测之前的一致性，如果之前的都不一致就根本不会append这个新的）\u003c/p\u003e\n\u003cp\u003e在Raft中，处理leader与follower的不一致性是通过强制把leader的log记录复制给follower来完成的，这意味着follower的log的冲突部分，会被完全覆盖。\u003c/p\u003e\n\u003cp\u003e为了使follwer的log保持一致，leader必须找到leader与follwer最近的一个一样的entry，然后把这个之后的log都发给follower。\u003c/p\u003e\n\u003cp\u003eleader对于每一个follower都维护了一个index，这个index是leader将要发给follower的下一个index，当一个leader上台后， 会把这个next index初始化为自己log中的最后一个index，如果有follower的记录与leader不一致，那么在下一次Append Entries RPC的一致性检查中失败。当这个调用失败后，leader将决定下一个next index是多少，最终，next index会在重试中到达leader与follower一致的地方。当RPC调用成功之后，leader会把之后的记录全发给follower，这样就follower就完成了与leader的一致性同步。\u003c/p\u003e","title":"raft extented论文笔记"},{"content":"这篇文章来自于Github的一篇关于Rust size的一些介绍，本文内容基本上是这文章的总结。可以话尽量看原文。\n介绍 sideness在Rust中是一个比较底层的概念，但是又比较重要，而且与许多Rust特性有关系。通常我们能在编译器的错误信息中看到x doesn't have size known at compile time，那么到底什么是sized type；什么是unsized type以及什么是zero-sized type。他们应该怎么使用，和一些优缺点。\n这有一张表是以一个总的视角来看Rust的type。\nPhrase Shorthand for sizedness property of being sized or unsized sized type type with a known size at compile time 1) unsized type or 2) DST dynamically-sized type, i.e. size not known at compile time ?sized type type that may or may not be sized unsized coercion coercing a sized type into an unsized type ZST zero-sized type, i.e. instances of the type are 0 bytes in size width single unit of measurement of pointer width 1) thin pointer or 2) single-width pointer pointer that is 1 width 1) fat pointer or 2) double-width pointer pointer that is 2 widths 1) pointer or 2) reference some pointer of some width, width will be clarified by context slice double-width pointer to a dynamically sized view into some array sizedness 到底什么叫sizedness呢，在Rust中，如果一个类型的大小能在编译器能确定下来，那就是一个sized type。确定一个类型的大小是非常重要的，因为这关系到在stack上申请多大内存，一个确定大小的类型能够pass by value and ref。如果一个type是 unsized type or DST(dynamic Sized Type)那么它就不能在stack上申请内存，这两种情况的变量只能pass by ref。\nuse std::mem::size_of; fn main() { // primitives assert_eq!(4, size_of::\u0026lt;i32\u0026gt;()); assert_eq!(8, size_of::\u0026lt;f64\u0026gt;()); // tuples assert_eq!(8, size_of::\u0026lt;(i32, i32)\u0026gt;()); // arrays assert_eq!(0, size_of::\u0026lt;[i32; 0]\u0026gt;()); assert_eq!(12, size_of::\u0026lt;[i32; 3]\u0026gt;()); struct Point { x: i32, y: i32, } // structs assert_eq!(8, size_of::\u0026lt;Point\u0026gt;()); // enums assert_eq!(8, size_of::\u0026lt;Option\u0026lt;i32\u0026gt;\u0026gt;()); // get pointer width, will be // 4 bytes wide on 32-bit targets or // 8 bytes wide on 64-bit targets const WIDTH: usize = size_of::\u0026lt;\u0026amp;()\u0026gt;(); // pointers to sized types are 1 width assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;i32\u0026gt;()); assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;mut i32\u0026gt;()); assert_eq!(WIDTH, size_of::\u0026lt;Box\u0026lt;i32\u0026gt;\u0026gt;()); assert_eq!(WIDTH, size_of::\u0026lt;fn(i32) -\u0026gt; i32\u0026gt;()); const DOUBLE_WIDTH: usize = 2 * WIDTH; // unsized struct struct Unsized { unsized_field: [i32], } // pointers to unsized types are 2 widths assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;str\u0026gt;()); // slice assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;[i32]\u0026gt;()); // slice assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;dyn ToString\u0026gt;()); // trait object assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;Box\u0026lt;dyn ToString\u0026gt;\u0026gt;()); // trait object assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;Unsized\u0026gt;()); // user-defined unsized type // unsized types size_of::\u0026lt;str\u0026gt;(); // compile error size_of::\u0026lt;[i32]\u0026gt;(); // compile error size_of::\u0026lt;dyn ToString\u0026gt;(); // compile error size_of::\u0026lt;Unsized\u0026gt;(); // compile error } 从上面的代码可以看出来，Rust中的原生类型都有确定的大小，像struct,enum,array，以及由原生与类型与指针或者其它nested struct enum等组成的类型都能在编译期确定大小。而像slice是不能确定大小的，因为我们并不知道这个slice到底会多大，这些只有运行时才会知道。\n一个指向动态大小视图的指针称为slice，比如\u0026amp;str就是string slice\nslice两个width大小是因为存了一个指向数据的指针与元素的数量\ntrait两个width大小是因为存一个指向数据的指针与指向虚表的指针\nunsized struct两个width大小是因为存了一个指针与这个struct 的大小\nunsized struct只能一个unsized filed而且这个必须是struct中的最后一个字段\n下面有些例子可以看slice跟array的区别：\nuse std::mem::size_of; const WIDTH: usize = size_of::\u0026lt;\u0026amp;()\u0026gt;(); const DOUBLE_WIDTH: usize = 2 * WIDTH; fn main() { // data length stored in type // an [i32; 3] is an array of three i32s let nums: \u0026amp;[i32; 3] = \u0026amp;[1, 2, 3]; // single-width pointer assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;[i32; 3]\u0026gt;()); let mut sum = 0; // can iterate over nums safely // Rust knows it\u0026#39;s exactly 3 elements for num in nums { sum += num; } assert_eq!(6, sum); // unsized coercion from [i32; 3] to [i32] // data length now stored in pointer let nums: \u0026amp;[i32] = \u0026amp;[1, 2, 3]; // double-width pointer required to also store data length assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;[i32]\u0026gt;()); let mut sum = 0; // can iterate over nums safely // Rust knows it\u0026#39;s exactly 3 elements for num in nums { sum += num; } assert_eq!(6, sum); } 下面有些例子可以看struct 与 trait的区别：\nuse std::mem::size_of; const WIDTH: usize = size_of::\u0026lt;\u0026amp;()\u0026gt;(); const DOUBLE_WIDTH: usize = 2 * WIDTH; trait Trait { fn print(\u0026amp;self); } struct Struct; struct Struct2; impl Trait for Struct { fn print(\u0026amp;self) { println!(\u0026#34;struct\u0026#34;); } } impl Trait for Struct2 { fn print(\u0026amp;self) { println!(\u0026#34;struct2\u0026#34;); } } fn print_struct(s: \u0026amp;Struct) { // always prints \u0026#34;struct\u0026#34; // this is known at compile-time s.print(); // single-width pointer assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;Struct\u0026gt;()); } fn print_struct2(s2: \u0026amp;Struct2) { // always prints \u0026#34;struct2\u0026#34; // this is known at compile-time s2.print(); // single-width pointer assert_eq!(WIDTH, size_of::\u0026lt;\u0026amp;Struct2\u0026gt;()); } fn print_trait(t: \u0026amp;dyn Trait) { // print \u0026#34;struct\u0026#34; or \u0026#34;struct2\u0026#34; ? // this is unknown at compile-time t.print(); // Rust has to check the pointer at run-time // to figure out whether to use Struct\u0026#39;s // or Struct2\u0026#39;s implementation of \u0026#34;print\u0026#34; // so the pointer has to be double-width assert_eq!(DOUBLE_WIDTH, size_of::\u0026lt;\u0026amp;dyn Trait\u0026gt;()); } fn main() { // single-width pointer to data let s = \u0026amp;Struct; print_struct(s); // prints \u0026#34;struct\u0026#34; // single-width pointer to data let s2 = \u0026amp;Struct2; print_struct2(s2); // prints \u0026#34;struct2\u0026#34; // unsized coercion from Struct to dyn Trait // double-width pointer to point to data AND Struct\u0026#39;s vtable let t: \u0026amp;dyn Trait = \u0026amp;Struct; print_trait(t); // prints \u0026#34;struct\u0026#34; // unsized coercion from Struct2 to dyn Trait // double-width pointer to point to data AND Struct2\u0026#39;s vtable let t: \u0026amp;dyn Trait = \u0026amp;Struct2; print_trait(t); // prints \u0026#34;struct2\u0026#34; } Sized Trait Sized trait是Rust一个marker trait和auto trait。auto trait是说如果一个类型满足了条件则会被自动实现。而markter trait说用来标记一个类型是某个特定的属性的。marker trait没有任何的trait item，比如函数，变量等。所有的auto trait都是marker trait，但是不是所有的marker trait都是auto trait。auto trait必须得是marker trait，这样编译器才能提供一个默认的实现 。 一个类型如果它的所有的成员都是sized的，那么它就是Sized。同样的trait还有Send与Sync。如果一个类型能安全地在线程间传递，那么它就是Send的，如果一个类型能在线程间安全的shared ref，那就是Sync的。但是Sized有点不同的是，不能对一个类型把它去掉：\n#![feature(negative_impls)] // this type is Sized, Send, and Sync struct Struct; // opt-out of Send trait impl !Send for Struct {} // opt-out of Sync trait impl !Sync for Struct {} impl !Sized for Struct {} // compile error 泛型参数中的Sized // this generic function... fn func\u0026lt;T\u0026gt;(t: T) {} // ...desugars to... fn func\u0026lt;T: Sized\u0026gt;(t: T) {} // ...which we can opt-out of by explicitly setting ?Sized... fn func\u0026lt;T: ?Sized\u0026gt;(t: T) {} // compile error // ...which doesn\u0026#39;t compile since t doesn\u0026#39;t have // a known size so we must put it behind a pointer... fn func\u0026lt;T: ?Sized\u0026gt;(t: \u0026amp;T) {} // compiles fn func\u0026lt;T: ?Sized\u0026gt;(t: Box\u0026lt;T\u0026gt;) {} // compiles 当我们写下一个泛型函数时，T就得到了Sized的trait。\n?Sized意思是这个类型可能是Sized或者是也许Sized的。这能让类型可以是Sized也可以的Unsized。 ?Sized一般用来减少参数的约束，且是Rust中唯一能减少约束的措施。 一般来说，我们还是需要放松对泛型参数的约束，因为实例化的时候， 实际类型可能是Sized也有可能是Unsized。 有如下代码：\nuse std::fmt::Debug; fn debug\u0026lt;T: Debug\u0026gt;(t: T) { // T: Debug + Sized println!(\u0026#34;{:?}\u0026#34;, t); } fn main() { debug(\u0026#34;my str\u0026#34;); // T = \u0026amp;str, \u0026amp;str: Debug + Sized ✔️ 虽然这样可行，但是如果参数是个ref呢？\nuse std::fmt::Debug; fn dbg\u0026lt;T: Debug\u0026gt;(t: \u0026amp;T) { // T: Debug + Sized println!(\u0026#34;{:?}\u0026#34;, t); } fn main() { dbg(\u0026#34;my str\u0026#34;); // \u0026amp;T = \u0026amp;str, T = str, str: Debug + !Sized ❌ } 错误如下：\nerror[E0277]: the size for values of type `str` cannot be known at compilation time --\u0026gt; src/main.rs:8:9 | 3 | fn dbg\u0026lt;T: Debug\u0026gt;(t: \u0026amp;T) { | - required by this bound in `dbg` ... 8 | dbg(\u0026#34;my str\u0026#34;); | ^^^^^^^^ doesn\u0026#39;t have a size known at compile-time | = help: the trait `std::marker::Sized` is not implemented for `str` = note: to learn more, visit \u0026lt;https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\u0026gt; help: consider relaxing the implicit `Sized` restriction | 3 | fn dbg\u0026lt;T: Debug + ?Sized\u0026gt;(t: \u0026amp;T) { | 这其中的类型也许有点怪，但是看表就很好理解了：\nType T \u0026amp;T \u0026amp;str T = \u0026amp;str T = str Type Sized str ❌ \u0026amp;str ✔️ \u0026amp;\u0026amp;str ✔️ 所以最好对泛型参数加上一个?Sized的标记来放松对类型的约束。\nUnsized type slices 最常见的切片是str与数组的切片\u0026amp;[T]。切片的一个优点是许多的类型都能转换成它们。强制类型转换在Rust中很常见，特别是在函数参数中。一种类型转换是deref和unsized。一个deref转换是当T通过一个deref操作转换成U，比如T:Deref\u0026lt;Target=U\u0026gt;比如STring.deref() -\u0026gt; str。一个unsized转换是把T转换成U，其中T是sized type 而U是unsized type。比如T:Unsized\u0026lt;U\u0026gt;，[i32;3] -\u0026gt;[i32]。\ntrait Trait { fn method(\u0026amp;self) {} } impl Trait for str { // can now call \u0026#34;method\u0026#34; on // 1) str or // 2) String since String: Deref\u0026lt;Target = str\u0026gt; } impl\u0026lt;T\u0026gt; Trait for [T] { // can now call \u0026#34;method\u0026#34; on // 1) any \u0026amp;[T] // 2) any U where U: Deref\u0026lt;Target = [T]\u0026gt;, e.g. Vec\u0026lt;T\u0026gt; // 3) [T; N] for any N, since [T; N]: Unsize\u0026lt;[T]\u0026gt; } fn str_fun(s: \u0026amp;str) {} fn slice_fun\u0026lt;T\u0026gt;(s: \u0026amp;[T]) {} fn main() { let str_slice: \u0026amp;str = \u0026#34;str slice\u0026#34;; let string: String = \u0026#34;string\u0026#34;.to_owned(); // function args str_fun(str_slice); str_fun(\u0026amp;string); // deref coercion // method calls str_slice.method(); string.method(); // deref coercion let slice: \u0026amp;[i32] = \u0026amp;[1]; let three_array: [i32; 3] = [1, 2, 3]; let five_array: [i32; 5] = [1, 2, 3, 4, 5]; let vec: Vec\u0026lt;i32\u0026gt; = vec![1]; // function args slice_fun(slice); slice_fun(\u0026amp;vec); // deref coercion slice_fun(\u0026amp;three_array); // unsized coercion slice_fun(\u0026amp;five_array); // unsized coercion // method calls slice.method(); vec.method(); // deref coercion three_array.method(); // unsized coercion five_array.method(); // unsized coercion } Trait Object 对于一个Trait来说，是?Sized的。因为不知道是Sized type 还是unsized type会去实现它。\nTrait : ?Sized对于impl Trait for dyn Trait是必要的。\n我们能对每一个方法加个Self:Sized的约束，但是不能给Trait加个Sized约束。\nTrait Object 的局限性 不能把一个Unsized的类型转换成Trait Object fn generic\u0026lt;T: ToString\u0026gt;(t: T) {} fn trait_object(t: \u0026amp;dyn ToString) {} fn main() { generic(String::from(\u0026#34;String\u0026#34;)); // compiles generic(\u0026#34;str\u0026#34;); // compiles trait_object(\u0026amp;String::from(\u0026#34;String\u0026#34;)); // compiles, unsized coercion trait_object(\u0026#34;str\u0026#34;); // compile error, unsized coercion impossible } 不能创造出多Trait的object的动态分发：因为要存两个trait的vtable要更多的内存，而正确的组合方式如下：\ntrait Trait { fn method(\u0026amp;self) {} } trait Trait2 { fn method2(\u0026amp;self) {} } trait Trait3: Trait + Trait2 {} // auto blanket impl Trait3 for any type that also impls Trait \u0026amp; Trait2 impl\u0026lt;T: Trait + Trait2\u0026gt; Trait3 for T {} // from `dyn Trait + Trait2` to `dyn Trait3` fn function(t: \u0026amp;dyn Trait3) { t.method(); // compiles t.method2(); // compiles } Rust的trait不支持向上转换：\ntrait Trait { fn method(\u0026amp;self) {} } trait Trait2 { fn method2(\u0026amp;self) {} } trait Trait3: Trait + Trait2 {} impl\u0026lt;T: Trait + Trait2\u0026gt; Trait3 for T {} struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026amp;dyn Trait) {} fn takes_trait2(t: \u0026amp;dyn Trait2) {} fn main() { let t: \u0026amp;dyn Trait3 = \u0026amp;Struct; takes_trait(t); // compile error takes_trait2(t); // compile error } 一个正确的做法的是去写显式的转换函数：\ntrait Trait {} trait Trait2 {} trait Trait3: Trait + Trait2 { fn as_trait(\u0026amp;self) -\u0026gt; \u0026amp;dyn Trait; fn as_trait2(\u0026amp;self) -\u0026gt; \u0026amp;dyn Trait2; } impl\u0026lt;T: Trait + Trait2\u0026gt; Trait3 for T { fn as_trait(\u0026amp;self) -\u0026gt; \u0026amp;dyn Trait { self } fn as_trait2(\u0026amp;self) -\u0026gt; \u0026amp;dyn Trait2 { self } } struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026amp;dyn Trait) {} fn takes_trait2(t: \u0026amp;dyn Trait2) {} fn main() { let t: \u0026amp;dyn Trait3 = \u0026amp;Struct; takes_trait(t.as_trait()); // compiles takes_trait2(t.as_trait2()); // compiles } User-Defined Unsized Type struct Unsized { unsized_field: [i32], } 定义一个unsized type的方法是，给struct一个unsize filed。这个unsized filed只能一个，且是最后一个。\n如果要定义一个不知道是不是Unsized type的struct，最好是用泛型去定义这个struct。\n我们常用的std::ffi:OsStr与std::path::Path就是标准库中的unsized struct。\nZero-Sized Types Unit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。\n尽管()是0大小类型，但是还是能给它实现一些trait：\nuse std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026amp;self, _other: \u0026amp;()) -\u0026gt; bool { true } fn ne(\u0026amp;self, _other: \u0026amp;()) -\u0026gt; bool { false } } impl Ord for () { fn cmp(\u0026amp;self, _other: \u0026amp;()) -\u0026gt; Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如：\nfn main() { // zero capacity is all the capacity we need to \u0026#34;store\u0026#34; infinitely many () let mut vec: Vec\u0026lt;()\u0026gt; = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。\nUser-Defined Unit Structs 用户定义的Unit Struct:\nstruct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。\nNever type Never type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是：\n!能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型\n而第二点可以实现出一定会成功的函数:\nfn function() -\u0026gt; Result\u0026lt;Success, !\u0026gt;; 而fn function() -\u0026gt; Result\u0026lt;!, Error\u0026gt;;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。\nUser-Defined Pseudo Never Type 我们可以用用户自定义的never type来实现永远不会失败的函数：\nenum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026amp;str) -\u0026gt; Result\u0026lt;String, Self::Err\u0026gt; { Ok(String::from(s)) } } // example 2 fn run_server() -\u0026gt; Result\u0026lt;Void, ConnectionError\u0026gt; { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","permalink":"https://linxy.dev/posts/rust-sized-type/","summary":"\u003cp\u003e这篇文章来自于Github的一篇关于\u003ca href=\"https://github.com/pretzelhammer/rust-blog/blob/master/posts/sizedness-in-rust.md\"\u003eRust size\u003c/a\u003e的一些介绍，本文内容基本上是这文章的总结。可以话尽量看原文。\u003c/p\u003e","title":"Rust Sized Trait与类型大小"},{"content":"前言 MIT 6.824是著名的分布式课程，课程包含了视频，讲义，与作业。而本篇博文将阐述6.824课程的第一个作业的一些思考与解法，记录一些关于Map Reduce系统的思考。\nMap Reduce Map Reduce作为“谷三篇”的第一篇，出名不是没有原因的，jeff dean的超前思想构建了谷歌搜索的基石，使得谷歌在超大应用系统的构建上得心应手。而Map Reduce则是一个基石中的基石。\nMap Reduce的思想就是分布式的，系统中包含一个Master和许多个Worker，Master负责调度Worker与任务分发，容灾等等，Worker则与Master通信，请求任务。\n而Map Reduce则把一个任务拆分成Map与Reduce部分，简单来说，Map部分是把输入通过用户定义的Map Function输出成中间文件，再把中间文件作为输入给Reduce，Reduce把中间文件调用Reduce Function，然后合并并输出。\n整个系统如图所示。如论文所说，这些文件可以是在本地机器上，也可以在分布式文件系统中，这并不影响整个系统框架。\n具体Map Reduce的思想可以读一下Google的论文。\nMIT 6.824 Lab1 现代的6.824比以前的要难许多，我做过之前的lab1，当时就把Map Reduce的框架都搭好了，只要写两个函数就算通过了。而这个2020的6.824要求对Go熟悉且要把MapReduce整个实现一个大概出来，前后花了不少时间去思考要怎么来做这个实验。\n思考 当我们拿到Lab的时候需要做什么？需要思考我们要实现哪些东西。MIT的代码里只给了几个RPC的函数，然后在这个基础去实现Map Reduce。\n而我们要做的有：\n实现Master管理，这其中需要管理任务的状态，Worker请求任务的处理，Worker任务完成报告的处理，Worker失败超时的处理。 实现Worker请求任务，对Map部分任务的处理，对Reduce部分任务的处理，还有任务完成的上报。 还要实现一个文件锁，不能让Goroutine之间产生Race。 实现 我的一些方案是在Master的结构体里管理两个Channel，当Master启动之后，把任务发给MapChannel，然后在另一个Goroutine里面对这个MapChannel进行读取，Channel如果不设置的话，一方没有读，写方会阻塞住，所以只有Worker进行请求任务之后才会继续生产任务。当Map部分完成后，再启动Reduce部分，生产Reduce任务到ReduceChannel。\n我们在每个请求任务的RPC返回之前再开启一个Goroutine来等待Worker的任务完成报告，这里我们用到了Go的select语法，并使用一个timer，如果超时就把这个任务再次Push进TaskChannel，即使任务失败了，也能再次把任务分发下去。\n对于Worker部分的代码来说，完全就是苦力活，可以看看官方代码里那个非分布式的Worker里代码，可以直接复制过来。Worker如果联系不上Master了，马上退出进程，这样就不用实现一个退出语义了。（其实是我不知道怎么让Master去通知Worker退出）\n代码 这里只给出一些结构体的定义：\nMaster:\ntype Master struct { MapTaskList []*MapTask ReduceTaskList []*ReduceTask MapTaskChan chan *MapTask ReduceTaskChan chan *ReduceTask CompleteMapTaskNum int CompleteReduceTaskNum int mu sync.Mutex files []string nReduce int } Task Def\ntype MapTask struct { TaskNum int TaskStatus TASK_STATUS FileName string NReduce int } type ReduceTask struct { TaskNum int TaskStatus TASK_STATUS FileName []string NReduce int } 一些吐槽 这次写了蛮久了，因为不是很熟悉Go，学了一会才知道有select这种语法，然后官方的hint里让人把中间文件命名为mr-x-y.txt，这样其实挺坑的，因为testmr.sh里面没有把这个中间文件删除掉，而在文件读写的时候因为hash的缘故，不会把所有的文件清空，这样导致前一个test的中间文件会影响到后一个test。所以我加一个函数，把所有的中间文件清空的，这样也算是TDD吧。\n接下来就是要做Lab2了，完成一个Raft。\n","permalink":"https://linxy.dev/posts/map-reduce/","summary":"\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003eMIT 6.824是著名的分布式课程，课程包含了视频，讲义，与作业。而本篇博文将阐述6.824课程的第一个作业的一些思考与解法，记录一些关于Map Reduce系统的思考。\u003c/p\u003e\n\u003ch1 id=\"map-reduce\"\u003eMap Reduce\u003c/h1\u003e\n\u003cp\u003eMap Reduce作为“谷三篇”的第一篇，出名不是没有原因的，jeff dean的超前思想构建了谷歌搜索的基石，使得谷歌在超大应用系统的构建上得心应手。而Map Reduce则是一个基石中的基石。\u003c/p\u003e\n\u003cp\u003eMap Reduce的思想就是分布式的，系统中包含一个Master和许多个Worker，Master负责调度Worker与任务分发，容灾等等，Worker则与Master通信，请求任务。\u003c/p\u003e\n\u003cp\u003e而Map Reduce则把一个任务拆分成Map与Reduce部分，简单来说，Map部分是把输入通过用户定义的Map Function输出成中间文件，再把中间文件作为输入给Reduce，Reduce把中间文件调用Reduce Function，然后合并并输出。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/mapreduce.png\"\u003e\u003c/p\u003e\n\u003cp\u003e整个系统如图所示。如论文所说，这些文件可以是在本地机器上，也可以在分布式文件系统中，这并不影响整个系统框架。\u003c/p\u003e\n\u003cp\u003e具体Map Reduce的思想可以读一下Google的论文。\u003c/p\u003e\n\u003ch1 id=\"mit-6824-lab1\"\u003eMIT 6.824 Lab1\u003c/h1\u003e\n\u003cp\u003e现代的6.824比以前的要难许多，我做过之前的lab1，当时就把Map Reduce的框架都搭好了，只要写两个函数就算通过了。而这个2020的6.824要求对Go熟悉且要把MapReduce整个实现一个大概出来，前后花了不少时间去思考要怎么来做这个实验。\u003c/p\u003e\n\u003ch2 id=\"思考\"\u003e思考\u003c/h2\u003e\n\u003cp\u003e当我们拿到Lab的时候需要做什么？需要思考我们要实现哪些东西。MIT的代码里只给了几个RPC的函数，然后在这个基础去实现Map Reduce。\u003c/p\u003e\n\u003cp\u003e而我们要做的有：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e实现Master管理，这其中需要管理任务的状态，Worker请求任务的处理，Worker任务完成报告的处理，Worker失败超时的处理。\u003c/li\u003e\n\u003cli\u003e实现Worker请求任务，对Map部分任务的处理，对Reduce部分任务的处理，还有任务完成的上报。\u003c/li\u003e\n\u003cli\u003e还要实现一个文件锁，不能让Goroutine之间产生Race。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"实现\"\u003e实现\u003c/h2\u003e\n\u003cp\u003e我的一些方案是在Master的结构体里管理两个Channel，当Master启动之后，把任务发给MapChannel，然后在另一个Goroutine里面对这个MapChannel进行读取，Channel如果不设置的话，一方没有读，写方会阻塞住，所以只有Worker进行请求任务之后才会继续生产任务。当Map部分完成后，再启动Reduce部分，生产Reduce任务到ReduceChannel。\u003c/p\u003e\n\u003cp\u003e我们在每个请求任务的RPC返回之前再开启一个Goroutine来等待Worker的任务完成报告，这里我们用到了Go的select语法，并使用一个timer，如果超时就把这个任务再次Push进TaskChannel，即使任务失败了，也能再次把任务分发下去。\u003c/p\u003e\n\u003cp\u003e对于Worker部分的代码来说，完全就是苦力活，可以看看官方代码里那个非分布式的Worker里代码，可以直接复制过来。Worker如果联系不上Master了，马上退出进程，这样就不用实现一个退出语义了。（其实是我不知道怎么让Master去通知Worker退出）\u003c/p\u003e\n\u003ch2 id=\"代码\"\u003e代码\u003c/h2\u003e\n\u003cp\u003e这里只给出一些结构体的定义：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMaster:\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eMaster\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eMapTaskList\u003c/span\u003e    \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eMapTask\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eReduceTaskList\u003c/span\u003e \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eReduceTask\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eMapTaskChan\u003c/span\u003e    \u003cspan class=\"kd\"\u003echan\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eMapTask\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eReduceTaskChan\u003c/span\u003e \u003cspan class=\"kd\"\u003echan\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eReduceTask\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eCompleteMapTaskNum\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eCompleteReduceTaskNum\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003emu\u003c/span\u003e      \u003cspan class=\"nx\"\u003esync\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eMutex\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003efiles\u003c/span\u003e   \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003enReduce\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003eTask Def\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eMapTask\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eTaskNum\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eTaskStatus\u003c/span\u003e \u003cspan class=\"nx\"\u003eTASK_STATUS\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eFileName\u003c/span\u003e   \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eNReduce\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eReduceTask\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eTaskNum\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eTaskStatus\u003c/span\u003e \u003cspan class=\"nx\"\u003eTASK_STATUS\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eFileName\u003c/span\u003e   \u003cspan class=\"p\"\u003e[]\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003eNReduce\u003c/span\u003e    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"一些吐槽\"\u003e一些吐槽\u003c/h2\u003e\n\u003cp\u003e这次写了蛮久了，因为不是很熟悉Go，学了一会才知道有select这种语法，然后官方的hint里让人把中间文件命名为mr-x-y.txt，这样其实挺坑的，因为testmr.sh里面没有把这个中间文件删除掉，而在文件读写的时候因为hash的缘故，不会把所有的文件清空，这样导致前一个test的中间文件会影响到后一个test。所以我加一个函数，把所有的中间文件清空的，这样也算是TDD吧。\u003c/p\u003e\n\u003cp\u003e接下来就是要做Lab2了，完成一个Raft。\u003c/p\u003e","title":"MIT 6.824 Lab1 mapreduce"}]