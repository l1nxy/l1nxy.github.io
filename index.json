[{"categories":null,"content":"好久没有写过年度总结类的文章了，最大的原因是在年底回忆起来，一年可能什么也没做，实在不太好写；即使写出来也会是充满了悔恨的文字，颇有熬夜之后，临睡之前的悔恨之意。 扯远了，那么2024年做了些啥呢？ ","date":"2024-12-30","objectID":"/2024/:0:0","series":null,"tags":null,"title":"2024总结","uri":"/2024/#"},{"categories":null,"content":" 运动2024年最大的成功就是完成了两场半程马拉松，备赛时间从7月到10月底，刚好四个月。最好成绩是在杭州以1小时43分钟完赛。本来目标应该是跑进140的，但是在10月中的时候，一周无休的情况下，出去骑了100km，导致自己左脚踝受伤了，后面就只能停跑，到11月初参加比赛的时候，有氧水平掉了很多；杭州马拉松跑完的时候，脚真的是疼的不行，休息了一周硬顶上了南昌马拉松，以150完赛，当时感叹一下能完赛就算成功吧。 在当前时间节点看来，备赛的4个月是我感觉状态最好的时候，睡眠质量好，吃的也多，爬山也很轻松。多运动确实有好处吧。骑车今年骑的不多了，因为秋天转跑步了，所以后面都只是穿插了一下骑行活动，但是今年依旧跑了1000公里，骑了2000公里。 25年的目标就是以330完赛全马吧，虽然现在一个比赛都没中过，也没开始备赛。 ","date":"2024-12-30","objectID":"/2024/:1:0","series":null,"tags":null,"title":"2024总结","uri":"/2024/#运动"},{"categories":null,"content":" 书今年读了43本书，大多是推理小说与读库，还有一些文学类的，举几本印象深刻的。 《流俗地》，年初读的，读了之后就感叹道肯定是个人24年TOP1的书，文笔无可挑剔。也算是为我打了南洋文学的一扇门吧。 《罪与罚》，年尾读的，读完后感觉陀爷真是神人，对杀人这件事的心理描写拿捏的如此精准，可见一定杀过人。 《悉达多》，主角宛如圣人一般的寓言故事。 《雾切7》，我们在群里多次提到了雾切，只能说这作的开篇和结尾确实花了心思，也是写的最好的。 ","date":"2024-12-30","objectID":"/2024/:2:0","series":null,"tags":null,"title":"2024总结","uri":"/2024/#书"},{"categories":null,"content":" 游戏今年唯一打完的单机游戏是baldr sky，好多游戏只打了个开篇就没有玩了。其中的原因是有些游戏后面是个悲剧，我不太愿意面对。有些是我人太浮躁，玩不太下去。开了很多游戏坑，还是得沉下心来好好体验这些游戏啊。 一句话总结就是上半年大多数时间在打雀魂，下半年跑步几乎不打游戏，12月在打CS。 ","date":"2024-12-30","objectID":"/2024/:3:0","series":null,"tags":null,"title":"2024总结","uri":"/2024/#游戏"},{"categories":null,"content":" 剧与动漫与电影今年看了不少剧，看的好电影也不少，提一些印象深刻的 《我的天才女友》123季都看完了，第4季看了一半，前面123季拍的真很好，让我感觉老意大利真的美。 《好东西》，算是年度好电影了吧，我看完的体验是到底谁在急眼呢，很多人都急眼了，感觉被攻击的是自己，可是电影中并没有攻击别人。电影更多的是表现女性生活，可以说并不止步女性的生活。 《因果报应》，应该是我的年度悬疑电影吧。即便是印度电影，仍然体现的是女性主义的核心。 《恶魔的破坏》，虽然还没有看完，但是值得我写一笔，动画体现的是日本的一种真实，而这些真实正在被消费，我感觉很诡异，但是实际上这种真实就是用来消费了，消费了才能有反馈啊。 《异形》，retro风格的电影，镜头挺有讲究的，算是看的爽的一类电影。 《JOJO5》，算是星尘十字军之后最好的一部吧，布姐的精神最好的诠释了黄金之风。 《葬送的芙莉莲》，应该算我的年度动漫，制作好，音乐好听，周指活。 《请回答1988》，18年开始看的，终于在今年看完了。几度看泪目了，时代与群像剧的TOP1吧。另外提一嘴《小巷人家》，本来能超越1988，可惜前8集能看。 ","date":"2024-12-30","objectID":"/2024/:4:0","series":null,"tags":null,"title":"2024总结","uri":"/2024/#剧与动漫与电影"},{"categories":null,"content":" 技术今年尝试给Rust Analyzer提了几个PR，给apache下面的项目做了贡献，虽然都是些小小的，但是至少跨出了自己做开源的第一步，打破了自己心目中神化了提开源PR这么一件事的印象。其实大多数项目都一样，只是草台程度不同的区别。 Rust方面读了Rust Atomic（这是本好书），然后拿Rust写了一个私活项目，可能也有几万行吧，算是实践的部分。另外这个项目还有客户端部分，写了一个月的avalonio，感觉写GUI体验真不太好，只能说GUI的editor跟游戏的editor都一样，真要做的好用，确实太难了。 另外读了几本技术书，但是感觉都一般，就不提了。 可见25年还是得多写多读，不能再懈怠了。 ","date":"2024-12-30","objectID":"/2024/:5:0","series":null,"tags":null,"title":"2024总结","uri":"/2024/#技术"},{"categories":null,"content":" 生活今年9月买了一辆车，极大的扩大了行动的范围，虽然因为我们太宅，没有太出去走，但是至少多了一个出行的选择。 家里三只猫，两只在年初的时候治好了病毒性口炎，也就年中的时候小猫肠胃炎去了一次医院，相对来说，猫仔的生活也算是很好了。 去了一次胡彦斌的演唱会，爽听了三小时，也算是值回了票价了。 去了一次初音的演唱会，体验了一下打call，虽然中文歌有点多，但是体验仍是不错的，可能这就是二次元吧。 ","date":"2024-12-30","objectID":"/2024/:6:0","series":null,"tags":null,"title":"2024总结","uri":"/2024/#生活"},{"categories":null,"content":" 总结24年当时定下的目标其实很简单，就是走出舒适区，多去体验体验生活，现在来看，基本完成了目标了；体验了很多之前没有干过的事，看过不少自己以前没有看过的电影，剧的类型。 那么展望25年，25年的目标就是技术上精进一步，搞一个side project试试，游戏上打完海猫与BG3，十三机兵，阅读上一定要读完的是陀爷的书；运动上330完赛全马。 ","date":"2024-12-30","objectID":"/2024/:7:0","series":null,"tags":null,"title":"2024总结","uri":"/2024/#总结"},{"categories":["Game"],"content":" 去年这时候，mwish 推荐给我一个galgame:Baldr Sky,我一直以来对galgame是不太感冒的，总感觉是与色色有关的游戏，而在游戏中寻找这种元素似乎是一件比较蠢的事；另外一个原因是，在我的认知中，一个黄油很难会有什么好的人物塑造，上来就推倒这种剧情显的很傻。而baldr sky是一个颠覆了我对galgame认知的作品，剧情音乐战斗都是超一流的优秀，而H的部分在这些看来真的很显的多余。 蕾线 作为开篇的线，本线做的非常好，玩家刚上手游戏，并不知道这个世界是怎么样的，而主人公甲在剧情中也是失忆状态的，所有的世界观与剧情都会随着记忆的恢复慢慢展开给玩家。不知道是不是故意而为之，制作组把蕾这样的一个人物放在最前面的，让后面的线推的时候，很难无视掉rain的付出，从而更加加深了对蕾的印象。蕾的人物塑造也非常鲜活，战场上给甲爷辅助，生活上给甲爷如同贤内助一般的照顾，可以说蕾是最完美的忠犬。在后面的线中，蕾无法作为女主出现在主流剧情中，但是仍然表现出来了对甲的忠诚，对甲隐藏的爱，这让我感觉非常的对不起她，难怪蕾是人气最高的角色。蕾线的Good ending是甲爷跟蕾远走高飞，过上了幸福的生活，可以说是非常甜的结局了，如果故事只限于此，而它将是平庸的作品。 菜叶线 菜叶线我印象最深的是结局中那个浪漫的场景，菜叶线紧接着蕾线，慢慢的把这个世界发生的事更加细化的展开来，让玩家发现这个世界不只是简单的一条故事线那么简单，总会有人死去。菜叶是一个非常可怜的女孩子，对老师充满了信任，最后却被利用了，不过我感觉这条线的情感有点牵强。在这条线中的千夏死掉了，从而引出了千夏线。 千夏线 我对千夏线只有愤怒，千夏塑造的非常好，学生时期的乐观与直球都是在隐藏自己，到后面发现了自己目标，哪怕让自己死也要达成目标。但是，这条线的甲爷塑造的太失败了，居然为了千夏大杀特杀，手刃蕾与魔狼的人，这对我来说简直不理喻，甲爷不是这样一个角色，为了爱情可以抛弃所有的人啊。千夏惨也是真的惨，千夏线她能得到幸福也是应该的。但是最后居然住到了Rain家里，这特么是什么鬼？还要在她家做。真是见鬼。 亚季线 我个人觉得亚季线真的是编剧写的最好的一条线，主要是在情感上被编剧牵着走，对于是不是乱伦这个问题，我感觉我的心情在过山车，而编剧用了好几层诡叙来震撼玩家。而亚季与情感线在我看来也比千夏与菜叶来的更加自然。 真线 真线其实我感觉更多的像是工具人线一般，因为情感上似乎也不是很能自恰，要说喜欢，我觉得真最多只是崇拜吧，而真因为一个恶作剧让自己承担上了无比沉重的责任，这样的写法让真这个角色更加有血有肉了。 空线 个人觉得空线其实写的挺一般，主要是文本量摆在那，但是要做的事情太多了，前面还要插进去一些救回各个女主，有些太过于冗长，如果更多的笔墨分到与空的情感交互上就更好了。不过空线作为收篇线，后半段非常的好，一个燃系机甲游戏，大甲收到各个世界线的甲的信念与记忆后，大喊Dr19，终结这一切吧后，BGM响起，与Dr19的战斗开始了，情感在这一刻到达了最顶峰，千千万万场战斗，最终都是为了救空，而空也独自撑了千万年。打完了Dr19后，我感觉到一丝解脱，终于结束了，终于救回了空。 jihad与沉默之空的音乐也为本作增色许多，在与千夏的战斗中，响起了BGM之时，真是太带感了。 战斗系统简约但不简单，也是到后期我才开发出一套连招可以输出很高，才在决战之时不那么痛苦，但是空线的战斗实在太多了，有些战斗真的又臭又长了。最后的True ending我也没有再打了，只能云一下了。 长达69小时的游玩，只能说这游戏确实是神作。 一些缺点：游戏不能放其它盘，容易闪退，而空线闪退频率太高了，好多战斗我都打了好多遍。 个人喜好线：空线=亚季线=rain线 \u003e 菜叶线 \u003e 真线 \u003e 千夏线 个人女主喜好：蕾 = 空 \u003e 千夏 \u003e 亚季 \u003e 真 \u003e 菜叶。 ","date":"2024-07-08","objectID":"/baldr-sky/:0:0","series":null,"tags":["game"],"title":"终结这一切吧！Baldr Sky游玩感受","uri":"/baldr-sky/#"},{"categories":["Tech"],"content":" 前言最近把系统换成了CachyOS，用上了ZFS，这个发行版做的一些Tricky还是可以的，例如一些fish的脚本，还有软件与DE的自定义项都比较简洁，比ArcoLinux强上不少。 我的情况是有两块NVMe的硬盘，一块是Windows系统，一块则是CachyOS。我的期望是用Linux Boot Manager去引导两个操作系统，比用Windows Boot Manager去引导Linux要好操作不少。 ","date":"2023-10-05","objectID":"/systemd-boot-windows/:0:0","series":null,"tags":["Linux","CachyOS","ArchLinux"],"title":"systemd-boot添加Windows引导项","uri":"/systemd-boot-windows/#前言"},{"categories":["Tech"],"content":" 确定fs alias看了一下systemd-boot的文档，需要先安装 edk2-shell 来给systemd-boot 加个EFI shell: sudo pacman -S edk2-shell \u0026\u0026 cp /usr/share/edk2-shell/x64/Shell.efi /boot/shellx64.efi 然后在boot的时候选择EFI Shell，在shell中，输入map命令，可以得到所有盘的fs alias, 这里我们需要得到是另一块盘的EFI分区。 可以用blkid可以看到所有盘or分区的PARTUUID，在EFI shell的map命令的输出结果中，可以对应上具体的fs alias是哪个盘。 ","date":"2023-10-05","objectID":"/systemd-boot-windows/:0:0","series":null,"tags":["Linux","CachyOS","ArchLinux"],"title":"systemd-boot添加Windows引导项","uri":"/systemd-boot-windows/#确定fs-alias"},{"categories":["Tech"],"content":" 加上Boot脚本确定了fs alias后就好办了，在/boot/下面新建一个windows.nsh，内容如下： HD0b:EFI\\Microsoft\\Boot\\Bootmgfw.efi 在这里，我的windows EFI分区的fs alias是HD0b。 然后在/boot/loader/entries/下面新建一个引导项windows.conf： title Windows efi /shellx64.efi options -nointerrupt -noconsolein -noconsoleout windows.nsh 最后检查一下windows.nsh是否在/boot/目录下面，用bootctl list 看一下boot项的输出，我的输出如下： type: Boot Loader Specification Type #1 (.conf) title: Windows id: windows.conf source: /boot//loader/entries/windows.conf efi: /boot//shellx64.efi options: -nointerrupt -noconsolein -noconsoleout windows.nsh type: Boot Loader Specification Type #1 (.conf) title: Linux Cachyos Lts Lto (default) (selected) id: linux-cachyos-lts-lto.conf source: /boot//loader/entries/linux-cachyos-lts-lto.conf linux: /boot//vmlinuz-linux-cachyos-lts-lto initrd: /boot//amd-ucode.img /boot//initramfs-linux-cachyos-lts-lto.img options: zfs=zpcachyos/ROOT/cos/root rw zswap.enabled=0 nowatchdog type: Boot Loader Specification Type #1 (.conf) title: Linux Cachyos Lts Lto (Fallback) id: linux-cachyos-lts-lto-fallback.conf source: /boot//loader/entries/linux-cachyos-lts-lto-fallback.conf linux: /boot//vmlinuz-linux-cachyos-lts-lto initrd: /boot//amd-ucode.img /boot//initramfs-linux-cachyos-lts-lto-fallback.img options: zfs=zpcachyos/ROOT/cos/root rw 可以确定的是，如果输出正确，那么就可以在引导的时候选择windows了。 PS，如果要改默认选择项，在/boot/loader/loader.conf 中可以改掉默认引导项，或者使用bootctl set-default 来指定。 ","date":"2023-10-05","objectID":"/systemd-boot-windows/:0:0","series":null,"tags":["Linux","CachyOS","ArchLinux"],"title":"systemd-boot添加Windows引导项","uri":"/systemd-boot-windows/#加上boot脚本"},{"categories":["Tech"],"content":" 添加Hook自动生成2023-11-16更新： 上述方案有个问题，如果每更新内核的话，entryies目录下的配置文件会被清空，所以需要有一个机制让内核更新的时候也能把windows.conf复制进去。 这里我选择的是，新建一个service，新建一个pacman的hook，每次在内核更新的时候，会触发hook，然后启动service，将处于其它路径中的配置文件复制到boot分区中去。 方法如下： 在非boot目录放置上述两个文件:windows.nsh 与windows.conf。这里我选择的目录是~/conf; 在/etc/systemd/system/下面新建一个update-windows-boot.service ： [Unit] Description=Update Windows boot entry [Service] ExecStart=/usr/bin/update-windows-entry.sh 在/usr/bin/下面新建update-windows-entry.sh，别忘记chmod +x 加上权限: #!/bin/bash cp /home/linxy/conf/windows.nsh /boot/ cp /home/linxy/conf/windows.conf /boot/loader/entries/ 在/etc/pacman.d/hooks下面新建update-windows-entry.hook: [Trigger] Operation = Upgrade Type = Package Target = linux-cachyos Target = linux-cachyos-lts Target = linux-lts Target = linux [Action] Description = Updating Windows boot entry... When = PostTransaction Exec = /usr/bin/systemctl start update-windows-boot.service 其中，target指的就是升级什么包的时候会触发这个hook。配置完成后，即可以在每次升级内核的时候保持windows的boot项。 TODO：也许可以把service去掉，直接执行脚本。有时间再研究吧 ","date":"2023-10-05","objectID":"/systemd-boot-windows/:0:0","series":null,"tags":["Linux","CachyOS","ArchLinux"],"title":"systemd-boot添加Windows引导项","uri":"/systemd-boot-windows/#添加hook自动生成"},{"categories":null,"content":" 暗香·旧时月色[宋]姜夔 旧时月色，算几番照我，梅边吹笛? 唤起玉人，不管清寒与攀摘。 何逊而今渐老，都忘却春风词笔。 但怪得竹外疏花，香冷入瑶席。 江国，正寂寂，叹寄与路遥，夜雪初积。。 翠尊易泣，红萼无言耿相忆。 长记曾携手处，千树压、西湖寒碧。又片片、吹尽也，几时见得? ","date":"2023-08-07","objectID":"/about/:0:0","series":null,"tags":null,"title":"About","uri":"/about/#"},{"categories":["Tech"],"content":" raft基础一个raft集群一般来说有5个服务器结点，能让系统承受其中任意两台的down掉。每个服务器一共有三个状态，leader,follower,candidate,follower被动的接受来自candidate与leader的消息并作出回应。leader handle了所有了所有的客户端的请求，如果follower接收到了请求，会重定向到leader那去。 raft把时间分成任意长的阶段，从选举开始，每个阶段都是一个连续增长的整数，至少有一个或者多个candidate会尝试成为leader。如果有一个candidate成为了leader，则接下来的term，它将是leader。在一些情况下，选举会出现，平分票数的情况，这种情况，term将会维持没有leader的状态到结束，到下一次的新的选举。 不同的服务器 可能感知不到不同的term之间的转换，或者根本不知道有选举这回事，在这其中，term充当了一个逻辑时钟的作用，能让服务器能检测过时的信息，比如落后的leader。每一个服务器有一个current term number，随着时间增长，当服务器之间通信时，current term 会被 交换，如果有一个服务器的term小于别的，就会更新自己的，如果一个canditate或者leader发现它自己的term过时了，就会马上转变成follower，如果服务器收到了一个过时的请求，则会直接拒绝这个请求。 raft的服务器之间用rpc请行通信，其中RequestVote用于canditate 来进行选举，AppendEntries 用于分发log与当心跳包（事实上是无论收到一个请求，都应该重置time out chekcer）。另外 还有一个转移快照的rpc。之后 再说。 ","date":"2020-08-30","objectID":"/raft-notes/:0:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#raft基础"},{"categories":["Tech"],"content":" 选举raft使用心跳机制来触发选举。当服务器启动的时候，它们都是follower，follower在收到来自leader或者 candidate合法的rpc请求之前，一直是follower，leader会周期性的发送心跳包来保持leader的权威性，心跳包是一个空的AppendEntries，不带有Log entries。当一个follower一个election timeout后没有收到心跳包，则认为leader没了，将开始一轮选举，选出一个新的leader。 为了开始一次选举，follower会给current term+1然后转变成candidate，然后投自己一票，然后同时发起RequestVote RPC给别的服务器。一个candidate会持续到以下三件情况出现，(a)它成了leader，(b)其它服务器成了leader(c)一段时间过去后，没有server成为leader。这将在之后讨论（应该是过一段时间重新发起） 一个candidate如果收到了整个集群中大多数的投票 (with same term)，就会成为leader。每一个服务器最多只能投出一票。这个大多数 的规则决定了，在一个term里，只能一个candidate成为leader。一旦candidate成为了leader，则会开始发送心跳包给其它所有的服务器，来保证自己的权威与阻止其它服务器发起选举。 在投票的过程中，可能 会收到来其它服务器发来的AppendEntries RPC来声称自己是leader，这种情况，看leader的term与自己的current term的大小，如果比自己大，那别人就是leader，自己将退回到follower的状态，如果比自己小，就是拒绝别人的RPC call，并继续进行选举。 一个选举如果选不出一个leader那就是分裂的选举，即没人得到大多数票，这种情况下，会等待超时直到下一次的选举，但是如果 没有做额外的操作，分裂的选举会不停的进行下去。 raft采用了随机的选举超时来保证split vote是很少见的并且能快速的被解决。即每一个服务器的election timeout不一样，在重新发起选举的之前会等待这个timeout，timeout少的会先发起选举。一般的timeout会选择一个区间比如150-300ms之间。这样会有一个服务器超时完成并在别的服务器节点超时完成前完成选举。 ","date":"2020-08-30","objectID":"/raft-notes/:0:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#选举"},{"categories":["Tech"],"content":" Log replication一旦一个leader被选举，那它就开始接受client的请求，每一个client的请求都包含一个命令，这个命令会被 replicated state machines执行，leader将会把这个command append到日志中去，作为一个新的entry，然后用AppendEntries 分发到其它的服务器。 leader会永远的尝试去写入follower log entry，直到所有的log entry都被 写入。 leader决定什么时候日志被 commit，当大多数的服务器都复制了一份entry后，就会提交，也会提前之前的entries，论文中设计了两个重要的属性 如果不同日志中的两个Entry有一样的index跟term，那他们存的一个东西 如果不同日志中的两个entry有一样的index跟term，那他们之前的所有entry是相同的。 属性1保证了，在给定的term与index中只会创建一个entry，属性2保证了一致性的简单性。 如果follower发现leader发过来的index跟term在自己的log里没有，那么会拒绝这个新的entry。（因为在消息中包含了这条新的之前的index跟term，所以可以检测之前的一致性，如果之前的都不一致就根本不会append这个新的） 在Raft中，处理leader与follower的不一致性是通过强制把leader的log记录复制给follower来完成的，这意味着follower的log的冲突部分，会被完全覆盖。 为了使follwer的log保持一致，leader必须找到leader与follwer最近的一个一样的entry，然后把这个之后的log都发给follower。 leader对于每一个follower都维护了一个index，这个index是leader将要发给follower的下一个index，当一个leader上台后， 会把这个next index初始化为自己log中的最后一个index，如果有follower的记录与leader不一致，那么在下一次Append Entries RPC的一致性检查中失败。当这个调用失败后，leader将决定下一个next index是多少，最终，next index会在重试中到达leader与follower一致的地方。当RPC调用成功之后，leader会把之后的记录全发给follower，这样就follower就完成了与leader的一致性同步。 leader永远不会改自己的log。这是强保证。 ","date":"2020-08-30","objectID":"/raft-notes/:0:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#log-replication"},{"categories":["Tech"],"content":" 强约束为了达成算法的强一致性，必须加上一些强约束。 ","date":"2020-08-30","objectID":"/raft-notes/:0:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#强约束"},{"categories":["Tech"],"content":" 选举RPC必须包含candidate的log，然后投票者看canditate的log是否比自己的旧，如果旧，则会拒绝投给它，这样会保证选举出来的leader跟大多数的投票者中的log是一致的。 ","date":"2020-08-30","objectID":"/raft-notes/:1:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#选举-1"},{"categories":["Tech"],"content":" 非提交的entryraft不会提交之前阶段的非提交的entry。对于raft来说，如果leader当前的entry提交了，其中的潜在的语义包含了之前的entry都是提交了的。 ","date":"2020-08-30","objectID":"/raft-notes/:2:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#非提交的entry"},{"categories":["Tech"],"content":" 安全性争论这部分主要是证明future term的log是 一定包含了之前term的提交的，因为如果没提交的话，会有两个矛盾，第一，它成为不了leader，第二，它的entry log一定比之前的要大。原文中用的反证法，说term U没有包含term T的 log。实际上，在投票的时候 它成为不了leader，另外一个就是假如它是leader，它的log也得包含之前的，不然提交不了到follower。 ","date":"2020-08-30","objectID":"/raft-notes/:3:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#安全性争论"},{"categories":["Tech"],"content":" 崩溃如果follower或者candidate崩溃了，leader会一直发请求，直到成功，如果follower在commit log之后但是没有回复，之后重启了，发现收到了同样index的entry写入请求，会忽视这个请求。 ","date":"2020-08-30","objectID":"/raft-notes/:4:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#崩溃"},{"categories":["Tech"],"content":" 时间与可用性raft的安全性不应该依赖时间：系统不应该因为一些事件发生的比预期的慢或者快就产生错误的结果。然而可用性却是不可避免的依赖时间。例如，因为如果回复慢了，follower就要变成candidate了。 其中leader election是raft中对时间最敏感的。raft将会选出一个稳定的leader，且这个系统满足这样的延迟要求：broadcastTime \u003c electionTimout \u003c MTBF。 广播时间应该要比选举超时少一个数量级，而选举时间应该要比恢复时间要少几个数量级。这样当leader崩溃的时候，也只有选举时间内不可用而已。 通常来说broadcasttim从0.5ms到20ms不等，而选举超时从10 ms 到500ms不等。而mtbf几个月。 ","date":"2020-08-30","objectID":"/raft-notes/:5:0","series":null,"tags":["raft","system design"],"title":"raft extented论文笔记","uri":"/raft-notes/#时间与可用性"},{"categories":["Tech"],"content":"这篇文章来自于Github的一篇关于Rust size的一些介绍，本文内容基本上是这文章的总结。可以话尽量看原文。 ","date":"2020-08-24","objectID":"/rust-sized-type/:0:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#"},{"categories":["Tech"],"content":" 介绍sideness在Rust中是一个比较底层的概念，但是又比较重要，而且与许多Rust特性有关系。通常我们能在编译器的错误信息中看到x doesn't have size known at compile time，那么到底什么是sized type；什么是unsized type以及什么是zero-sized type。他们应该怎么使用，和一些优缺点。 这有一张表是以一个总的视角来看Rust的type。 Phrase Shorthand for sizedness property of being sized or unsized sized type type with a known size at compile time 1) unsized type or 2) DST dynamically-sized type, i.e. size not known at compile time ?sized type type that may or may not be sized unsized coercion coercing a sized type into an unsized type ZST zero-sized type, i.e. instances of the type are 0 bytes in size width single unit of measurement of pointer width 1) thin pointer or 2) single-width pointer pointer that is 1 width 1) fat pointer or 2) double-width pointer pointer that is 2 widths 1) pointer or 2) reference some pointer of some width, width will be clarified by context slice double-width pointer to a dynamically sized view into some array ","date":"2020-08-24","objectID":"/rust-sized-type/:0:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#介绍"},{"categories":["Tech"],"content":" sizedness到底什么叫sizedness呢，在Rust中，如果一个类型的大小能在编译器能确定下来，那就是一个sized type。确定一个类型的大小是非常重要的，因为这关系到在stack上申请多大内存，一个确定大小的类型能够pass by value and ref。如果一个type是 unsized type or DST(dynamic Sized Type)那么它就不能在stack上申请内存，这两种情况的变量只能pass by ref。 use std::mem::size_of; fn main() { // primitives assert_eq!(4, size_of::\u003ci32\u003e()); assert_eq!(8, size_of::\u003cf64\u003e()); // tuples assert_eq!(8, size_of::\u003c(i32, i32)\u003e()); // arrays assert_eq!(0, size_of::\u003c[i32; 0]\u003e()); assert_eq!(12, size_of::\u003c[i32; 3]\u003e()); struct Point { x: i32, y: i32, } // structs assert_eq!(8, size_of::\u003cPoint\u003e()); // enums assert_eq!(8, size_of::\u003cOption\u003ci32\u003e\u003e()); // get pointer width, will be // 4 bytes wide on 32-bit targets or // 8 bytes wide on 64-bit targets const WIDTH: usize = size_of::\u003c\u0026()\u003e(); // pointers to sized types are 1 width assert_eq!(WIDTH, size_of::\u003c\u0026i32\u003e()); assert_eq!(WIDTH, size_of::\u003c\u0026mut i32\u003e()); assert_eq!(WIDTH, size_of::\u003cBox\u003ci32\u003e\u003e()); assert_eq!(WIDTH, size_of::\u003cfn(i32) -\u003e i32\u003e()); const DOUBLE_WIDTH: usize = 2 * WIDTH; // unsized struct struct Unsized { unsized_field: [i32], } // pointers to unsized types are 2 widths assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026str\u003e()); // slice assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026[i32]\u003e()); // slice assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026dyn ToString\u003e()); // trait object assert_eq!(DOUBLE_WIDTH, size_of::\u003cBox\u003cdyn ToString\u003e\u003e()); // trait object assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026Unsized\u003e()); // user-defined unsized type // unsized types size_of::\u003cstr\u003e(); // compile error size_of::\u003c[i32]\u003e(); // compile error size_of::\u003cdyn ToString\u003e(); // compile error size_of::\u003cUnsized\u003e(); // compile error } 从上面的代码可以看出来，Rust中的原生类型都有确定的大小，像struct,enum,array，以及由原生与类型与指针或者其它nested struct enum等组成的类型都能在编译期确定大小。而像slice是不能确定大小的，因为我们并不知道这个slice到底会多大，这些只有运行时才会知道。 一个指向动态大小视图的指针称为slice，比如\u0026str就是string slice slice两个width大小是因为存了一个指向数据的指针与元素的数量 trait两个width大小是因为存一个指向数据的指针与指向虚表的指针 unsized struct两个width大小是因为存了一个指针与这个struct 的大小 unsized struct只能一个unsized filed而且这个必须是struct中的最后一个字段 下面有些例子可以看slice跟array的区别： use std::mem::size_of; const WIDTH: usize = size_of::\u003c\u0026()\u003e(); const DOUBLE_WIDTH: usize = 2 * WIDTH; fn main() { // data length stored in type // an [i32; 3] is an array of three i32s let nums: \u0026[i32; 3] = \u0026[1, 2, 3]; // single-width pointer assert_eq!(WIDTH, size_of::\u003c\u0026[i32; 3]\u003e()); let mut sum = 0; // can iterate over nums safely // Rust knows it's exactly 3 elements for num in nums { sum += num; } assert_eq!(6, sum); // unsized coercion from [i32; 3] to [i32] // data length now stored in pointer let nums: \u0026[i32] = \u0026[1, 2, 3]; // double-width pointer required to also store data length assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026[i32]\u003e()); let mut sum = 0; // can iterate over nums safely // Rust knows it's exactly 3 elements for num in nums { sum += num; } assert_eq!(6, sum); } 下面有些例子可以看struct 与 trait的区别： use std::mem::size_of; const WIDTH: usize = size_of::\u003c\u0026()\u003e(); const DOUBLE_WIDTH: usize = 2 * WIDTH; trait Trait { fn print(\u0026self); } struct Struct; struct Struct2; impl Trait for Struct { fn print(\u0026self) { println!(\"struct\"); } } impl Trait for Struct2 { fn print(\u0026self) { println!(\"struct2\"); } } fn print_struct(s: \u0026Struct) { // always prints \"struct\" // this is known at compile-time s.print(); // single-width pointer assert_eq!(WIDTH, size_of::\u003c\u0026Struct\u003e()); } fn print_struct2(s2: \u0026Struct2) { // always prints \"struct2\" // this is known at compile-time s2.print(); // single-width pointer assert_eq!(WIDTH, size_of::\u003c\u0026Struct2\u003e()); } fn print_trait(t: \u0026dyn Trait) { // print \"struct\" or \"struct2\" ? // this is unknown at compile-time t.print(); // Rust has to check the pointer at run-time // to figure out whether to use Struct's // or Struct2's implementation of \"print\" // so the pointer has to be double-width assert_eq!(DOUBLE_WIDTH, size_of::\u003c\u0026dyn Trait\u003e()); } fn main() { // single-width pointer to data let s = \u0026Struct; print_struct(s); // prints \"struct\" // single-width pointer to data let s2 = \u0026Struct2; print_struct2(s2); // prints \"struct2\" // unsized coercion from Struct to dyn Tr","date":"2020-08-24","objectID":"/rust-sized-type/:1:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#sizedness"},{"categories":["Tech"],"content":" Sized TraitSized trait是Rust一个marker trait和auto trait。auto trait是说如果一个类型满足了条件则会被自动实现。而markter trait说用来标记一个类型是某个特定的属性的。marker trait没有任何的trait item，比如函数，变量等。所有的auto trait都是marker trait，但是不是所有的marker trait都是auto trait。auto trait必须得是marker trait，这样编译器才能提供一个默认的实现 。 一个类型如果它的所有的成员都是sized的，那么它就是Sized。同样的trait还有Send与Sync。如果一个类型能安全地在线程间传递，那么它就是Send的，如果一个类型能在线程间安全的shared ref，那就是Sync的。但是Sized有点不同的是，不能对一个类型把它去掉： #![feature(negative_impls)] // this type is Sized, Send, and Sync struct Struct; // opt-out of Send trait impl !Send for Struct {} // opt-out of Sync trait impl !Sync for Struct {} impl !Sized for Struct {} // compile error ","date":"2020-08-24","objectID":"/rust-sized-type/:2:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#sized-trait"},{"categories":["Tech"],"content":" 泛型参数中的Sized// this generic function... fn func\u003cT\u003e(t: T) {} // ...desugars to... fn func\u003cT: Sized\u003e(t: T) {} // ...which we can opt-out of by explicitly setting ?Sized... fn func\u003cT: ?Sized\u003e(t: T) {} // compile error // ...which doesn't compile since t doesn't have // a known size so we must put it behind a pointer... fn func\u003cT: ?Sized\u003e(t: \u0026T) {} // compiles fn func\u003cT: ?Sized\u003e(t: Box\u003cT\u003e) {} // compiles 当我们写下一个泛型函数时，T就得到了Sized的trait。 ?Sized意思是这个类型可能是Sized或者是也许Sized的。这能让类型可以是Sized也可以的Unsized。 ?Sized一般用来减少参数的约束，且是Rust中唯一能减少约束的措施。 一般来说，我们还是需要放松对泛型参数的约束，因为实例化的时候， 实际类型可能是Sized也有可能是Unsized。 有如下代码： use std::fmt::Debug; fn debug\u003cT: Debug\u003e(t: T) { // T: Debug + Sized println!(\"{:?}\", t); } fn main() { debug(\"my str\"); // T = \u0026str, \u0026str: Debug + Sized ✔️ 虽然这样可行，但是如果参数是个ref呢？ use std::fmt::Debug; fn dbg\u003cT: Debug\u003e(t: \u0026T) { // T: Debug + Sized println!(\"{:?}\", t); } fn main() { dbg(\"my str\"); // \u0026T = \u0026str, T = str, str: Debug + !Sized ❌ } 错误如下： error[E0277]: the size for values of type `str` cannot be known at compilation time --\u003e src/main.rs:8:9 | 3 | fn dbg\u003cT: Debug\u003e(t: \u0026T) { | - required by this bound in `dbg` ... 8 | dbg(\"my str\"); | ^^^^^^^^ doesn't have a size known at compile-time | = help: the trait `std::marker::Sized` is not implemented for `str` = note: to learn more, visit \u003chttps://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\u003e help: consider relaxing the implicit `Sized` restriction | 3 | fn dbg\u003cT: Debug + ?Sized\u003e(t: \u0026T) { | 这其中的类型也许有点怪，但是看表就很好理解了： Type T \u0026T \u0026str T = \u0026str T = str Type Sized str ❌ \u0026str ✔️ \u0026\u0026str ✔️ 所以最好对泛型参数加上一个?Sized的标记来放松对类型的约束。 ","date":"2020-08-24","objectID":"/rust-sized-type/:3:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#泛型参数中的sized"},{"categories":["Tech"],"content":" Unsized type","date":"2020-08-24","objectID":"/rust-sized-type/:4:0","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#unsized-type"},{"categories":["Tech"],"content":" slices最常见的切片是str与数组的切片\u0026[T]。切片的一个优点是许多的类型都能转换成它们。强制类型转换在Rust中很常见，特别是在函数参数中。一种类型转换是deref和unsized。一个deref转换是当T通过一个deref操作转换成U，比如T:Deref\u003cTarget=U\u003e比如STring.deref() -\u003e str。一个unsized转换是把T转换成U，其中T是sized type 而U是unsized type。比如T:Unsized\u003cU\u003e，[i32;3] -\u003e[i32]。 trait Trait { fn method(\u0026self) {} } impl Trait for str { // can now call \"method\" on // 1) str or // 2) String since String: Deref\u003cTarget = str\u003e } impl\u003cT\u003e Trait for [T] { // can now call \"method\" on // 1) any \u0026[T] // 2) any U where U: Deref\u003cTarget = [T]\u003e, e.g. Vec\u003cT\u003e // 3) [T; N] for any N, since [T; N]: Unsize\u003c[T]\u003e } fn str_fun(s: \u0026str) {} fn slice_fun\u003cT\u003e(s: \u0026[T]) {} fn main() { let str_slice: \u0026str = \"str slice\"; let string: String = \"string\".to_owned(); // function args str_fun(str_slice); str_fun(\u0026string); // deref coercion // method calls str_slice.method(); string.method(); // deref coercion let slice: \u0026[i32] = \u0026[1]; let three_array: [i32; 3] = [1, 2, 3]; let five_array: [i32; 5] = [1, 2, 3, 4, 5]; let vec: Vec\u003ci32\u003e = vec![1]; // function args slice_fun(slice); slice_fun(\u0026vec); // deref coercion slice_fun(\u0026three_array); // unsized coercion slice_fun(\u0026five_array); // unsized coercion // method calls slice.method(); vec.method(); // deref coercion three_array.method(); // unsized coercion five_array.method(); // unsized coercion } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:1","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#slices"},{"categories":["Tech"],"content":" Trait Object对于一个Trait来说，是?Sized的。因为不知道是Sized type 还是unsized type会去实现它。 Trait : ?Sized对于impl Trait for dyn Trait是必要的。 我们能对每一个方法加个Self:Sized的约束，但是不能给Trait加个Sized约束。 Trait Object 的局限性 不能把一个Unsized的类型转换成Trait Object fn generic\u003cT: ToString\u003e(t: T) {} fn trait_object(t: \u0026dyn ToString) {} fn main() { generic(String::from(\"String\")); // compiles generic(\"str\"); // compiles trait_object(\u0026String::from(\"String\")); // compiles, unsized coercion trait_object(\"str\"); // compile error, unsized coercion impossible } 不能创造出多Trait的object的动态分发：因为要存两个trait的vtable要更多的内存，而正确的组合方式如下： trait Trait { fn method(\u0026self) {} } trait Trait2 { fn method2(\u0026self) {} } trait Trait3: Trait + Trait2 {} // auto blanket impl Trait3 for any type that also impls Trait \u0026 Trait2 impl\u003cT: Trait + Trait2\u003e Trait3 for T {} // from `dyn Trait + Trait2` to `dyn Trait3` fn function(t: \u0026dyn Trait3) { t.method(); // compiles t.method2(); // compiles } Rust的trait不支持向上转换： trait Trait { fn method(\u0026self) {} } trait Trait2 { fn method2(\u0026self) {} } trait Trait3: Trait + Trait2 {} impl\u003cT: Trait + Trait2\u003e Trait3 for T {} struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026dyn Trait) {} fn takes_trait2(t: \u0026dyn Trait2) {} fn main() { let t: \u0026dyn Trait3 = \u0026Struct; takes_trait(t); // compile error takes_trait2(t); // compile error } 一个正确的做法的是去写显式的转换函数： trait Trait {} trait Trait2 {} trait Trait3: Trait + Trait2 { fn as_trait(\u0026self) -\u003e \u0026dyn Trait; fn as_trait2(\u0026self) -\u003e \u0026dyn Trait2; } impl\u003cT: Trait + Trait2\u003e Trait3 for T { fn as_trait(\u0026self) -\u003e \u0026dyn Trait { self } fn as_trait2(\u0026self) -\u003e \u0026dyn Trait2 { self } } struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026dyn Trait) {} fn takes_trait2(t: \u0026dyn Trait2) {} fn main() { let t: \u0026dyn Trait3 = \u0026Struct; takes_trait(t.as_trait()); // compiles takes_trait2(t.as_trait2()); // compiles } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:2","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#trait-object"},{"categories":["Tech"],"content":" Trait Object对于一个Trait来说，是?Sized的。因为不知道是Sized type 还是unsized type会去实现它。 Trait : ?Sized对于impl Trait for dyn Trait是必要的。 我们能对每一个方法加个Self:Sized的约束，但是不能给Trait加个Sized约束。 Trait Object 的局限性 不能把一个Unsized的类型转换成Trait Object fn generic(t: T) {} fn trait_object(t: \u0026dyn ToString) {} fn main() { generic(String::from(\"String\")); // compiles generic(\"str\"); // compiles trait_object(\u0026String::from(\"String\")); // compiles, unsized coercion trait_object(\"str\"); // compile error, unsized coercion impossible } 不能创造出多Trait的object的动态分发：因为要存两个trait的vtable要更多的内存，而正确的组合方式如下： trait Trait { fn method(\u0026self) {} } trait Trait2 { fn method2(\u0026self) {} } trait Trait3: Trait + Trait2 {} // auto blanket impl Trait3 for any type that also impls Trait \u0026 Trait2 impl Trait3 for T {} // from `dyn Trait + Trait2` to `dyn Trait3` fn function(t: \u0026dyn Trait3) { t.method(); // compiles t.method2(); // compiles } Rust的trait不支持向上转换： trait Trait { fn method(\u0026self) {} } trait Trait2 { fn method2(\u0026self) {} } trait Trait3: Trait + Trait2 {} impl Trait3 for T {} struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026dyn Trait) {} fn takes_trait2(t: \u0026dyn Trait2) {} fn main() { let t: \u0026dyn Trait3 = \u0026Struct; takes_trait(t); // compile error takes_trait2(t); // compile error } 一个正确的做法的是去写显式的转换函数： trait Trait {} trait Trait2 {} trait Trait3: Trait + Trait2 { fn as_trait(\u0026self) -\u003e \u0026dyn Trait; fn as_trait2(\u0026self) -\u003e \u0026dyn Trait2; } impl Trait3 for T { fn as_trait(\u0026self) -\u003e \u0026dyn Trait { self } fn as_trait2(\u0026self) -\u003e \u0026dyn Trait2 { self } } struct Struct; impl Trait for Struct {} impl Trait2 for Struct {} fn takes_trait(t: \u0026dyn Trait) {} fn takes_trait2(t: \u0026dyn Trait2) {} fn main() { let t: \u0026dyn Trait3 = \u0026Struct; takes_trait(t.as_trait()); // compiles takes_trait2(t.as_trait2()); // compiles } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:2","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#trait-object-的局限性"},{"categories":["Tech"],"content":" User-Defined Unsized Typestruct Unsized { unsized_field: [i32], } 定义一个unsized type的方法是，给struct一个unsize filed。这个unsized filed只能一个，且是最后一个。 如果要定义一个不知道是不是Unsized type的struct，最好是用泛型去定义这个struct。 我们常用的std::ffi:OsStr与std::path::Path就是标准库中的unsized struct。 ","date":"2020-08-24","objectID":"/rust-sized-type/:4:3","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#user-defined-unsized-type"},{"categories":["Tech"],"content":" Zero-Sized TypesUnit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。 尽管()是0大小类型，但是还是能给它实现一些trait： use std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026self, _other: \u0026()) -\u003e bool { true } fn ne(\u0026self, _other: \u0026()) -\u003e bool { false } } impl Ord for () { fn cmp(\u0026self, _other: \u0026()) -\u003e Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如： fn main() { // zero capacity is all the capacity we need to \"store\" infinitely many () let mut vec: Vec\u003c()\u003e = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。 User-Defined Unit Structs用户定义的Unit Struct: struct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。 Never typeNever type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是： !能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型 而第二点可以实现出一定会成功的函数: fn function() -\u003e Result\u003cSuccess, !\u003e; 而fn function() -\u003e Result\u003c!, Error\u003e;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。 User-Defined Pseudo Never Type我们可以用用户自定义的never type来实现永远不会失败的函数： enum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026str) -\u003e Result\u003cString, Self::Err\u003e { Ok(String::from(s)) } } // example 2 fn run_server() -\u003e Result\u003cVoid, ConnectionError\u003e { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:4","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#zero-sized-types"},{"categories":["Tech"],"content":" Zero-Sized TypesUnit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。 尽管()是0大小类型，但是还是能给它实现一些trait： use std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026self, _other: \u0026()) -\u003e bool { true } fn ne(\u0026self, _other: \u0026()) -\u003e bool { false } } impl Ord for () { fn cmp(\u0026self, _other: \u0026()) -\u003e Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如： fn main() { // zero capacity is all the capacity we need to \"store\" infinitely many () let mut vec: Vec\u003c()\u003e = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。 User-Defined Unit Structs用户定义的Unit Struct: struct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。 Never typeNever type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是： !能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型 而第二点可以实现出一定会成功的函数: fn function() -\u003e Result; 而fn function() -\u003e Result\u003c!, Error\u003e;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。 User-Defined Pseudo Never Type我们可以用用户自定义的never type来实现永远不会失败的函数： enum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026str) -\u003e Result { Ok(String::from(s)) } } // example 2 fn run_server() -\u003e Result { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:4","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#user-defined-unit-structs"},{"categories":["Tech"],"content":" Zero-Sized TypesUnit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。 尽管()是0大小类型，但是还是能给它实现一些trait： use std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026self, _other: \u0026()) -\u003e bool { true } fn ne(\u0026self, _other: \u0026()) -\u003e bool { false } } impl Ord for () { fn cmp(\u0026self, _other: \u0026()) -\u003e Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如： fn main() { // zero capacity is all the capacity we need to \"store\" infinitely many () let mut vec: Vec\u003c()\u003e = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。 User-Defined Unit Structs用户定义的Unit Struct: struct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。 Never typeNever type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是： !能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型 而第二点可以实现出一定会成功的函数: fn function() -\u003e Result; 而fn function() -\u003e Result\u003c!, Error\u003e;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。 User-Defined Pseudo Never Type我们可以用用户自定义的never type来实现永远不会失败的函数： enum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026str) -\u003e Result { Ok(String::from(s)) } } // example 2 fn run_server() -\u003e Result { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:4","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#never-type"},{"categories":["Tech"],"content":" Zero-Sized TypesUnit Type: () and {}；每一个函数如果没有显示的return的话都会返回一个()。 尽管()是0大小类型，但是还是能给它实现一些trait： use std::cmp::Ordering; impl Default for () { fn default() {} } impl PartialEq for () { fn eq(\u0026self, _other: \u0026()) -\u003e bool { true } fn ne(\u0026self, _other: \u0026()) -\u003e bool { false } } impl Ord for () { fn cmp(\u0026self, _other: \u0026()) -\u003e Ordering { Ordering::Equal } } 编译器知道()是zero-sized type。比如： fn main() { // zero capacity is all the capacity we need to \"store\" infinitely many () let mut vec: Vec\u003c()\u003e = Vec::with_capacity(0); // causes no heap allocations or vec capacity changes vec.push(()); // len++ vec.push(()); // len++ vec.push(()); // len++ vec.pop(); // len-- assert_eq!(2, vec.len()); } 编译器就只会给Vec中的len操作，而不会在heap上去申请内存。 User-Defined Unit Structs用户定义的Unit Struct: struct Struct; 实际上Unit Struct比()有用的多，因为孤儿规则的存在，我们不能给()实现trait，因为它是标准库里的。这样我们可以实现一个等同的，更有意义的名字的Unit struct来给代码带来可读性。 Never typeNever type是第二个重要的ZST，它的代表了一个计算永远不会有结果的意思 。一些有趣的事情是： !能转换成其它任何类型 没法创建出一个！的实例。 第一点的用处在于宏与break,continue等都有!类型，使得可以用在返回结果里，因为能转换成任何类型 而第二点可以实现出一定会成功的函数: fn function() -\u003e Result; 而fn function() -\u003e Result\u003c!, Error\u003e;是永远不会成功的函数。因为在返回的时候 ，创造不出它的实例来。 User-Defined Pseudo Never Type我们可以用用户自定义的never type来实现永远不会失败的函数： enum Void {} // example 1 impl FromStr for String { type Err = Void; fn from_str(s: \u0026str) -\u003e Result { Ok(String::from(s)) } } // example 2 fn run_server() -\u003e Result { loop { let (request, response) = get_request()?; let result = request.process(); response.send(result); } } ","date":"2020-08-24","objectID":"/rust-sized-type/:4:4","series":null,"tags":["Rust"],"title":"Rust Sized Trait与类型大小","uri":"/rust-sized-type/#user-defined-pseudo-never-type"},{"categories":["Tech"],"content":" 前言MIT 6.824是著名的分布式课程，课程包含了视频，讲义，与作业。而本篇博文将阐述6.824课程的第一个作业的一些思考与解法，记录一些关于Map Reduce系统的思考。 ","date":"2020-07-02","objectID":"/map-reduce/:0:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#前言"},{"categories":["Tech"],"content":" Map ReduceMap Reduce作为“谷三篇”的第一篇，出名不是没有原因的，jeff dean的超前思想构建了谷歌搜索的基石，使得谷歌在超大应用系统的构建上得心应手。而Map Reduce则是一个基石中的基石。 Map Reduce的思想就是分布式的，系统中包含一个Master和许多个Worker，Master负责调度Worker与任务分发，容灾等等，Worker则与Master通信，请求任务。 而Map Reduce则把一个任务拆分成Map与Reduce部分，简单来说，Map部分是把输入通过用户定义的Map Function输出成中间文件，再把中间文件作为输入给Reduce，Reduce把中间文件调用Reduce Function，然后合并并输出。 整个系统如图所示。如论文所说，这些文件可以是在本地机器上，也可以在分布式文件系统中，这并不影响整个系统框架。 具体Map Reduce的思想可以读一下Google的论文。 ","date":"2020-07-02","objectID":"/map-reduce/:0:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#map-reduce"},{"categories":["Tech"],"content":" MIT 6.824 Lab1现代的6.824比以前的要难许多，我做过之前的lab1，当时就把Map Reduce的框架都搭好了，只要写两个函数就算通过了。而这个2020的6.824要求对Go熟悉且要把MapReduce整个实现一个大概出来，前后花了不少时间去思考要怎么来做这个实验。 ","date":"2020-07-02","objectID":"/map-reduce/:0:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#mit-6824-lab1"},{"categories":["Tech"],"content":" 思考当我们拿到Lab的时候需要做什么？需要思考我们要实现哪些东西。MIT的代码里只给了几个RPC的函数，然后在这个基础去实现Map Reduce。 而我们要做的有： 实现Master管理，这其中需要管理任务的状态，Worker请求任务的处理，Worker任务完成报告的处理，Worker失败超时的处理。 实现Worker请求任务，对Map部分任务的处理，对Reduce部分任务的处理，还有任务完成的上报。 还要实现一个文件锁，不能让Goroutine之间产生Race。 ","date":"2020-07-02","objectID":"/map-reduce/:1:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#思考"},{"categories":["Tech"],"content":" 实现我的一些方案是在Master的结构体里管理两个Channel，当Master启动之后，把任务发给MapChannel，然后在另一个Goroutine里面对这个MapChannel进行读取，Channel如果不设置的话，一方没有读，写方会阻塞住，所以只有Worker进行请求任务之后才会继续生产任务。当Map部分完成后，再启动Reduce部分，生产Reduce任务到ReduceChannel。 我们在每个请求任务的RPC返回之前再开启一个Goroutine来等待Worker的任务完成报告，这里我们用到了Go的select语法，并使用一个timer，如果超时就把这个任务再次Push进TaskChannel，即使任务失败了，也能再次把任务分发下去。 对于Worker部分的代码来说，完全就是苦力活，可以看看官方代码里那个非分布式的Worker里代码，可以直接复制过来。Worker如果联系不上Master了，马上退出进程，这样就不用实现一个退出语义了。（其实是我不知道怎么让Master去通知Worker退出） ","date":"2020-07-02","objectID":"/map-reduce/:2:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#实现"},{"categories":["Tech"],"content":" 代码这里只给出一些结构体的定义： Master: type Master struct { MapTaskList []*MapTask ReduceTaskList []*ReduceTask MapTaskChan chan *MapTask ReduceTaskChan chan *ReduceTask CompleteMapTaskNum int CompleteReduceTaskNum int mu sync.Mutex files []string nReduce int } Task Def type MapTask struct { TaskNum int TaskStatus TASK_STATUS FileName string NReduce int } type ReduceTask struct { TaskNum int TaskStatus TASK_STATUS FileName []string NReduce int } ","date":"2020-07-02","objectID":"/map-reduce/:3:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#代码"},{"categories":["Tech"],"content":" 一些吐槽这次写了蛮久了，因为不是很熟悉Go，学了一会才知道有select这种语法，然后官方的hint里让人把中间文件命名为mr-x-y.txt，这样其实挺坑的，因为testmr.sh里面没有把这个中间文件删除掉，而在文件读写的时候因为hash的缘故，不会把所有的文件清空，这样导致前一个test的中间文件会影响到后一个test。所以我加一个函数，把所有的中间文件清空的，这样也算是TDD吧。 接下来就是要做Lab2了，完成一个Raft。 ","date":"2020-07-02","objectID":"/map-reduce/:4:0","series":null,"tags":["mapreduce","system design"],"title":"MIT 6.824 Lab1 mapreduce","uri":"/map-reduce/#一些吐槽"}]